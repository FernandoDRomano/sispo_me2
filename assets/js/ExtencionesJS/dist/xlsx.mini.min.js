/ *! xlsx.js (C) 2013-presente SheetJS - http://sheetjs.com * /
var DO_NOT_EXPORT_CODEPAGE = true; var DO_NOT_EXPORT_JSZIP = true; var XLSX = {}; function make_xlsx_lib (e) {e.version = "0.15.4"; var r = 1200, t = 1252; var a = [874,932,936,949,950]; para ( var n = 0; n <= 8; ++ n) a.push (1250 + n); var i = {0: 1252,1: 65001,2: 65001,77: 1e4,128: 932,129: 949,130: 1361 , 134: 936,136: 950,161: 1253,162: 1254,163: 1258,177: 1255,178: 1256,186: 1257,204: 1251,222: 874,238: 1250,255: 1252,69: 6969}; var s = función (e) {if (a.indexOf (e) == - 1) return; t = i [0] = e}; función l () {s (1252)} var o = función (e) {r = e; s (e)}; función f () {o (1200); l ()} función c (e) {var r = []; para (var t = 0, a = e.length; t < a; ++ t) r [t] = e.charCodeAt (t); return r} función h (e) {var r = []; for (var t = 0; t <e.length >> 1; + + t) r [t] = String.fromCharCode (e.charCodeAt (2 * t) + (e.charCodeAt (2 * t + 1) << 8)); devuelve r.join ("")} función u ( e) {var r = []; for (var t = 0; t <e.length >> 1; ++ t) r [t] = String.fromCharCode (e.charCodeAt (2 * t + 1) + (e.charCodeAt (2 * t) << 8)); devuelve r.join ("")} var d = función (e) {var r = e.charCodeAt (0) , t = e.charCodeAt (1); if (r == 255 && t == 254) devuelve h (e.slice (2)); if (r == 254 && t == 255) devuelve u (e.slice (2) ); if (r == 65279) return e.slice (1); return e}; var p = function Sl (e) {return String.fromCharCode (e)}; var v = function Cl (e) {return String .fromCharCode (e)}; var m = nulo; var g = verdadero; var b = función _l () {var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 + / ="; return {encode: function (r) {var "=" a = 0, n = 0, i = 0, s = 0, l = 0, o = 0, f = 0; for (var c = 0; c <r.length;) {a = r.charCodeAt (c ++ ); s = a >> 2; n = r.charCodeAt (c ++); l = (a & 3) << 4 | n >> 4; i = r.charCodeAt (c ++); o = (n & 15) << 2 | i >> 6; f = i & 63; if (isNaN (n)) {o = f = 64} más if (isNaN (i)) {f = 64} t + = e.charAt (s) + e.charAt (l ) + e.charAt (o) + e.charAt (f)} devuelve t},decodificación: función r (t) {var a = ""; var n = 0, i = 0, s = 0, l = 0, o = 0, f = 0, c = 0; t = t.replace (/ [^ \ w \ + \ / \ =] / g, ""); for (var h = 0; h <t.length;) {l = e.indexOf (t.charAt (h ++)); o = e .indexOf (t.charAt (h ++)); n = l << 2 | o >> 4; a + = String.fromCharCode (n); f = e.indexOf (t.charAt (h ++)); i = (o & 15 ) << 4 | f >> 2; if (f! == 64) {a + = String.fromCharCode (i)} c = e.indexOf (t.charAt (h ++)); s = (f & 3) << 6 | c; if (c! == 64) {a + = String.fromCharCode (s)}} return a}}} (); var w = typeof Buffer! == "undefined" && typeof process! == "undefined" && typeof process.versions! == "undefined" && !! process.versions.node; var k = function () {}; if (typeof Buffer! == "undefined") {var y =! Buffer.from; if (! y) prueba {Buffer.from ("foo", "utf8")} catch (x) {y = true} k = y? function (e, r) {return r? new Buffer (e, r): new Buffer (e)}: Buffer.from.bind (Buffer); if (! Buffer.alloc) Buffer.alloc = function (e) {return new Buffer (e)}; if (! Buffer.allocUnsafe) Buffer.allocUnsafe = function (e) {return new Buffer (e )}} función S (e) {return w? Buffer.alloc (e): new Array (e)} function C (e) {return w? Buffer.allocUnsafe (e): new Array (e)} var _ = función Al (e) {if (w) devuelve k (e, "binario"); devuelve e.split (""). map (function (e) {return e.charCodeAt (0) & 255})}; función A (e) {if (typeof ArrayBuffer === "undefined") return _ (e); var r = new ArrayBuffer (e.length), t = new Uint8Array (r); for (var a = 0; a! = e.length; ++ a) t [a] = e.charCodeAt (a) & 255; return r} función E (e) {if (Array.isArray (e)) return e.map (function (e) {return String.fromCharCode (e)}). Join (""); var r = []; for (var t = 0; t <e.length; ++ t) r [t] = String.fromCharCode (e [t ]); devuelve r.join ("")} función T (e) {if (typeof Uint8Array === "undefined") arroja un nuevo error ("No compatible"); devuelve una nueva función Uint8Array (e)} F (e) {if (typeof ArrayBuffer == "undefined") arroja un nuevo error ("Unsupported"); if (e instancia de ArrayBuffer) devuelve F (new Uint8Array (e)); var r = new Array (e.length); for (var t = 0; t <e.length; ++ t) r [t] = e [t]; return r} var O = función (e) {return []. Concat.apply ([], e)}; var D = / \ u0000 / g, M = / [\ u0001- \ u0006] / g; var P = {}; var R = función El (e) {e.version = "0.10.2"; función r (e) {var r = "", t = e.length-1; while (t> = 0) r + = e. charAt (t -); return r} función t (e, r) {var t = ""; while (t.length <r) t + = e; return t} función a (e, r) {var a = "" + e; return a.length> = r? a: t ("0", ra.length) + a} function n (e, r) {var a = "" + e; return a.length> = r? a: t ("", ra.length) + a} función i (e, r) {var a = "" + e; return a.length> = r? a: a + t ("",ra.length)} function s (e, r) {var a = "" + Math.round (e); return a.length> = r? a: t ("0", ra.length) + a} function l (e, r) {var a = "" + e; devuelve a.length> = r? a: t ("0", ra.length) + a} var o = Math.pow (2,32); función f (e, r) {if (e> o || e <-o) devuelve s (e, r); var t = Math.round (e); devuelve l (t, r)} función c (e , r) {r = r || 0; return e.length> = 7 + r && (e.charCodeAt (r) | 32) === 103 && (e.charCodeAt (r + 1) | 32) === 101 && (e.charCodeAt (r + 2) | 32) === 110 && (e.charCodeAt (r + 3) | 32) === 101 && (e.charCodeAt (r + 4) | 32) === 114 && (e .charCodeAt (r + 5) | 32) === 97 && (e.charCodeAt (r + 6) | 32) === 108} var h = [["" Sun "," Sunday "], [" Mon ", "Lunes"], ["martes", "martes"], ["miércoles", "miércoles"], ["jueves", "jueves"], ["viernes", "viernes"],["Sáb", "Sábado"]]; var u = [["J", "Ene", "Enero"], ["F", "Febrero", "Febrero"], ["M", "Mar "," Marzo "], [" A "," abril "," abril "], [" M "," mayo "," mayo "], [" J "," junio "," junio "], [ "J", "Jul", "Julio"], ["A", "Ago", "Agosto"], ["S", "Sep", "Septiembre"], ["O", "Oct", "Octubre"], ["N", "Nov", "Noviembre"], ["D", "Dec", "Diciembre"]]; función d (e) {e [0] = "General"; e [1] = "0"; e [2] = "0.00"; e [3] = "#, ## 0"; e [4] = "#, ## 0.00"; e [9] = "0 % "; e [10] =" 0.00% "; e [11] =" 0.00E + 00 "; e [12] =" #? /? "; E [13] =" # ?? / ?? "; e [14] =" m / d / aa "; e [15] =" d-mmm-aa "; e [16] =" d-mmm "; e [17] =" mmm-aa "; e [18] =" h: mm AM / PM "; e [19] =" h : mm: ss AM / PM "; e [20] =" h: mm "; e [21] =" h: mm: ss "; e [22] =" m / d / aa h: mm "; e [37] = "#, ## 0; (#, ## 0)"; e [38] = "#, ## 0; [Rojo] (#, ## 0)"; e [39] = " #, ## 0.00; (#, ## 0.00) "; e [40] =" #, ## 0.00; [Rojo] (#, ## 0.00) "; e [45] =" mm: ss "; e [46] = "[h]: mm: ss"; e [47] = "mmss.0"; e [48] = "## 0.0E + 0"; e [49] = "@"; e [56] = '"上午 / 下午" hh "時" mm "分" ss "秒"'; e [65535] = "General"} var p = {}; d (p); función v (e, r , t) {var a = e <0? -1: 1; var n = e * a; var i = 0, s = 1, l = 0; var o = 1, f = 0, c = 0; var h = Math.floor (n); while (f <r) {h = Math.floor (n); l = h * s + i; c = h * f + o; if (nh <5e-8) descanso; n = 1 / (nh); i = s; s = l; o = f; f = c} if (c> r) {if (f> r) {c = o; l = i} else {c = f; l = s}} if (! t) return [0, a * l, c]; var u = Math.floor (a * l / c); return [u, a * lu * c, c]} función m (e, r, t) {if (e> 2958465 || e <0) devuelve nulo; var a = e | 0, n = Math.floor (86400 * (ea)), i = 0; var s = []; var l = {D: a, T: n, u: 86400 * (ea) -n, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0}; if (Math.abs (lu) <1e-6) lu = 0; if (r && r.date1904) a + = 1462; if (lu> .9999) {lu = 0; if (++ n == 86400) {lT = n = 0; ++ a; ++ lD}} if (a === 60) {s = t? [1317,10,29]: [1900,2 , 29]; i = 3} más si (a === 0) {s = t? [1317,8,29]: [1900,1,0]; i = 6} más {if (a> 60) --a; var o = new Date (1900,0,1); o.setDate (o.getDate () + a-1); s = [o.getFullYear (), o.getMonth () + 1, o .getDate ()]; i = o.getDay (); if (a <60) i = (i + 6)% 7; if (t) i = C (o, s)} ly = s [0]; lm = s [1]; ld = s [2]; lS = n% 60; n = Math.floor (n / 60); lM = n% 60; n = Math.floor (n / 60); lH = n; lq = i; return l} e.parse_date_code = m; var g = nueva Fecha (1899,11,31,0,0,0); var b = g.getTime (); var w = nueva Fecha (1900,2,1,0,0,0); función k (e, r) {var t = e.getTime (); if (r) t- = 1461 * 24 * 60 * 60 * 1e3; más si (e> = w) t + = 24 * 60 * 60 * 1e3; return (t- (b + (e.getTimezoneOffset () - g.getTimezoneOffset ()) * 6e4)) / ( 24 * 60 * 60 * 1e3)} función y (e) {return e.toString (10)} e._general_int = y; var x = función B () {var e = / \. (\ D * [1- 9]) 0 + $ /, r = / \. 0 * $ /, t = / \. (\ D * [1-9]) 0 + /, a = / \. 0 * [Ee] /, n = / (E [+ -]) (\ d) $ /; función i (e) {var r = e <0? 12: 11; var t = o (e.toFixed (12)); if (t. length <= r) return t; t = e.toPrecision (10); if (t.length <= r) return t; return e.toExponential (5)} function s (r) {var t = r.toFixed ( 11) .replace (e, ". $ 1"); if (t.length> (r <0? 12: 11)) t = r.toPrecision (6); return t} function l (e) {for (var r = 0; r! = e.length; ++ r) if ((e.charCodeAt (r) | 32) === 101) devuelve e.replace (t, ". $ 1"). replace (a, " E "). Replace (" e "," E "). Replace (n," $ 10 $ 2 ");return e} function o (t) {return t.indexOf (".")> - 1? t.replace (r, ""). replace (e, ". $ 1"): t} return function f (e) {var r = Math.floor (Math.log (Math.abs (e)) * Math.LOG10E), t; if (r> = - 4 && r <= - 1) t = e.toPrecision (10 + r); else if (Math.abs (r) <= 9) t = i (e); else if (r === 10) t = e.toFixed (10) .substr (0,12); else t = s ( e); return o (l (t))}} (); e._general_num = x; función S (e, r) {switch (typeof e) {case "string": return e; case "boolean": return e? "TRUE": "FALSE"; caso "número": return (e | 0) === e? y (e): x (e); case "undefined": return ""; case "object": if (e == null) return ""; if (e instanceof Date) return I (14, k (e, r && r.date1904), r);} arrojar un nuevo error ("valor no admitido en formato general:" + e) } e._general = S; función C () {return 0} función _ (e, r, t, n) {var i = "", s = 0,l = 0, o = ty, f, c = 0; conmutador (e) {caso 98: o = t.y + 543; caso 121: conmutador (longitud r) {caso 1:; caso 2: f = o % 100; c = 2; break; default: f = o% 1e4; c = 4; break;} break; case 109: switch (r.length) {case 1:; case 2: f = tm; c = r .length; break; case 3: return u [tm-1] [1]; case 5: return u [tm-1] [0]; default: return u [tm-1] [2];} break; case 100: switch (r.length) {case 1:; case 2: f = td; c = r.length; break; case 3: return h [tq] [0]; default: return h [tq] [1] ;} break; case 104: switch (r.length) {case 1:; case 2: f = 1 + (t.H + 11)% 12; c = r.length; break; default: throw "mala hora formato : "+ r;} break; case 72: switch (r.length) {case 1:; case 2: f = tH; c = r.length; break; default: throw" bad hour format: "+ r;} break; caso 77: switch (r.length) {case 1:; case 2: f = tM; c = r.length; break; default: throw "bad minute format:" + r;} break; case 115: if (r! = "s" && r! = "ss" && r! = ". 0" && r!= ". 00" && r! = ". 000") arroje "segundo formato incorrecto:" + r; if (tu === 0 && (r == "s" || r == "ss")) devuelve un ( tS, r.length); if (n> = 2) l = n === 3? 1e3: 100; sino l = n === 1? 10: 1; s = Math.round (l * (t. S + tu)); if (s> = 60 * l) s = 0; if (r === "s") devuelve s === 0? "0": "" + s / l; i = a (s, 2 + n); if (r === "ss") devuelve i.substr (0,2); return "." + i.substr (2, r.length-1); caso 90: interruptor (r) {case "[h]" :; case "[hh]": f = tD * 24 + tH; break; case "[m]" :; case "[mm]": f = (tD * 24 + tH) * 60 + tM; break; case "[s]" :; case "[ss]": f = ((tD * 24 + tH) * 60 + tM) * 60 + Math.round (t.S + tu); pausa; valor predeterminado: arrojar "formato incorrecto abstime:" + r;} c = r.length === 3? 1: 2; pausa; caso 101: f = o; c = 1;} if (c > 0) devuelve a (f, c); de lo contrario, devuelve ""} función A (e) {var r = 3; if (e.length <= r) devuelve e; var t = e.longitud% r, a = e.substr (0, t); para (; t! = e.length; t + = r) a + = (a.length> 0? ",": "") + e.substr ( t, r); devuelve a} var E = función z () {var e = /% / g; función s (r, a, n) {var i = a.replace (e, ""), s = a .length-i.length; devuelve E (r, i, n * Math.pow (10,2 * s)) + t ("%", s)} función l (e, r, t) {var a = r.length-1; while (r.charCodeAt (a-1) === 44) - a; return E (e, r.substr (0, a), t / Math.pow (10,3 * ( r.length-a)))} función o (e, r) {var t; var a = e.indexOf ("E") - e.indexOf (".") - 1; if (e.match (/ ^ # + 0.0E \ +0 $ /)) {if (r == 0) devuelve "0.0E + 0"; de lo contrario, si (r <0) devuelve "-" + o (e, -r); var n = e.indexOf ("."); if (n === - 1) n = e.indexOf ("E"); var i = Math.floor (Math.log (r) * Math.LOG10E)% n ; if (i <0) i + = n; t = (r / Math.pow (10, i)). toPrecision (a + 1 + (n + i)% n); if (t.indexOf ("e" ) === - 1) {var s = Math.floor (Math.log (r) * Math.LOG10E); if (t.indexOf (".") === - 1) t = t.charAt (0) + "." + T.substr (1) + "E +" + (st.length + i); de lo contrario t + = "E +" + (si); while (t.substr (0,2) === "0.") {t = t.charAt (0) + t.substr (2, n) + "." + t.substr (2 + n); t = t.replace (/ ^ 0 + ([1-9]) /, "$ 1"). replace (/ ^ 0 + \ ./, "0.")} t = t.replace (/ \ + - /, "-")} t = t.replace (/ ^ ([+ -]?) (\ d *) \. (\ d *) [Ee] /, función (e, r, t, a) { devuelve r + t + a.substr (0, (n + i)% n) + "." + a.substr (i) + "E"})} else t = r.toExponential (a); if (e .match (/ E \ +00 $ /) && t.match (/ e [+ -] \ d $ /)) t = t.substr (0, t.length-1) + "0" + t.charAt ( t.length-1); if (e.match (/ E \ - /) && t.match (/ e \ + /)) t = t.replace (/ e \ + /, "e"); devuelve t. reemplazar ("e", "E")} var c = / # (\? +) (?) \ / (?) (\ d +) /; función h (e, r, i) {var s = parseInt ( e [4], 10), l = Math.round (r * s), o = Math.floor (l / s); var f = lo * s, c = s; devuelve i + (o === 0? "": ""+ o) + "" + (f === 0? t ("", e [1] .length + 1 + e [4] .length): n (f, e [1] .length) + e [ 2] + "/" + e [3] + a (c, e [4] .length))} función u (e, r, a) {return a + (r === 0? "": "" + r) + t ("", e [1] .length + 2 + e [4] .length)} var d = / ^ # * 0 * \. ([0 #] +) /; var p = / \ ). * [0 #] /; var m = / \ (### \) ### \\? - #### /; función g (e) {var r = "", t; for (var a = 0; a! = e.length; ++ a) switch (t = e.charCodeAt (a)) {case 35: break; case 63: r + = ""; break; case 48: r + = "0" ; break; default: r + = String.fromCharCode (t);} return r} function b (e, r) {var t = Math.pow (10, r); return "" + Math.round (e * t) / t} función w (e, r) {if (r <("" + Math.round ((e-Math.floor (e)) * Math.pow (10, r))). length) {return 0 } return Math.round ((e-Math.floor (e)) * Math.pow (10, r))} función k (e, r) {if (r <("" + Math.round ((e- Math.floor (e)) * Math.pow (10, r))).longitud) {return 1} return 0} función y (e) {if (e <2147483647 && e> -2147483648) return "" + (e> = 0? e | 0: e-1 | 0); return "" + Math .floor (e)} función x (e, u, S) {if (e.charCodeAt (0) === 40 &&! u.match (p)) {var C = u.replace (/ \ (* /, "") .replace (/ \) /, ""). replace (/ \) /, ""); if (S> = 0) return x ("n", C, S); return "(" + x ("n", C, -S) + ")"} if (u.charCodeAt (u.length-1) === 44) devuelve l (e, u, S); if (u.indexOf (" % ")! == - 1) devuelve s (e, u, S); if (u.indexOf (" E ")! == - 1) devuelve o (u, S); if (u.charCodeAt (0 ) === 36) devuelve "$" + x (e, u.substr (u.charAt (1) == ""? 2: 1), S); var _; var T, F, O, D = Math.abs (S), M = S <0? "-": ""; if (u.match (/ ^ 00 + $ /)) devuelve M + f (D, u.length); if (u. match (/ ^ [#?] + $ /)) {_ = f (S, 0); if (_ === "0") _ = ""; return _.length> u.length? _: g (u.substr (0, u.length -_. length)) + _} if (T = u.match (c)) return h (T, D, M); if (u.match (/ ^ # + 0 + $ /)) devuelve M + f (D, u.length-u.indexOf ("0")); if (T = u.match (d)) {_ = b (S, T [1] .length). reemplazar (/^([^\.font>+)$/,"$ 1. "+ g (T [1])). reemplazar (/\.$/,"."+ g (T [1]))). reemplazar (/ \. (\ d *) $ /, function (e, r) {return "." + r + t ("0", g (T [1]). length-r.length)}); return u.indexOf ("0.")! == - 1? _: _. replace (/ ^ 0 \ ./, ".")} u = u.replace (/ ^ # + ([0.]) /,"$1");if(T=u.match(/^(0*)\.(#*)$/)){return M + b (D, T [2] .length) .replace (/ \. (\ d * [1-9]) 0 * $ /, ". $ 1"). replace (/ ^ (-? \ d *) $ /, "$ 1."). replace (/ ^ 0 \. /,T[1font>.length?"0.":".")}if(T=u.match(/^#{1,3},##0(\.?)$/))return M + A (f (D, 0)); if (T = u.match (/ ^ #, ## 0 \. ([# 0] * 0) $ /)) {return S <0? "-" + x (e, u, -S): A ("" + (Math.floor (S) + k (S, T [1] .length))) + "." + a (w (S, T [1 ]longitud), T [1] .length)} if (T = u.match (/ ^ #, # *, # 0 /)) return x (e, u.replace (/ ^ #, # *, /, " "), S); if (T = u.match (/ ^ ([0 #] +) (\\? - ([0 #] +)) + $ /)) {_ = r (x (e, u.replace (/ [\\ -] / g, ""), S)); F = 0; return r (r (u.replace (/ \\ / g, "")). replace (/ [0 #] / g, función (e) {return F <_. length? _. charAt (F ++): e === "0"? "0": ""}))} if (u.match (m) ) {_ = x (e, "##########", S); devuelve "(" + _. substr (0,3) + ")" + _. substr (3,3) + "-" + _. substr (6)} var P = ""; if (T = u.match (/ ^ ([# 0?] +) (?) \ / (?) ([# 0?] +) /)) {F = Math.min (T [4] .length, 7); O = v (D, Math.pow (10, F) -1, false); _ = "" + M; P = E ("n", T [1], O [1]); if (P.charAt (P.length-1) == "") P = P.substr (0, P.length-1) + "0"; _ + = P + T [2] + "/" + T [3]; P = i (O [2], F); if (P.length <T [4] .length) P = g (T [4] .substr (T [4] .length-P.length)) + P; _ + = P; return _} if (T = u.match (/ ^ # ([# 0?] +) (?) \ / (?) ([# 0?] +) /)) {F = Math.min (Math.max (T [1] .length, T [4] .length), 7); O = v (D, Math.pow (10, F) -1, verdadero); devuelve M + (O [0] || (O [1]? "": " 0 ")) +" "+ (O [1]? N (O [1], F) + T [2] +" / "+ T [3] + i (O [2], F): t ( "", 2 * F + 1 + T [2] .length + T [3] .length))} if (T = u.match (/ ^ [# 0?] + $ /)) {_ = F ( S, 0); if (u.length <= _. Length) return _; return g (u.substr (0, u.length -_. Length)) + _} if (T = u.match (/ ^ ([# 0?] +) \. ([# 0] +) $ /)) {_ = "" + S.toFixed (Math.min (T [2] .length, 10)). Replace (/ ( [^ 0]) 0 + $ /, "$ 1"); F = _. IndexOf ("."); Var R = u.indexOf (".") - F, N = u.length -_. Length- R; devuelve g (u.substr (0, R) + _ + u.substr (u.length-N))} if (T = u.match (/ ^ 00,000 \. ([# 0] * 0) $ /)){F=w(S,T[1font>.length);return S <0? "-" + x (e, u, -S): A (y (S)). Replace (/ ^ \ d, \ d {3} $ /, "0 $ &"). replace (/ ^ \ d * $ /, function (e) {return "00," + (e.length <3? a (0,3 -mi.length): "") + e}) + "." + a (F, T [1] .length)} switch (u) {case "###, ## 0.00": return x (e, "# , ## 0.00 ", S); caso" ###, ### ":; caso" ##, ### ":; caso" #, ### ": var I = A (f (D, 0)); return I! == "0"? M + I: ""; case "###, ###. 00": return x (e, "###, ## 0.00", S) .replace (/ ^ 0 \ ./, "."); case "#, ###. 00": return x (e, "#, ## 0.00", S) .replace (/ ^ 0 \ ./ , "."); predeterminado:;} arrojar nuevo error ("formato no compatible |" + u + "|")} función S (e, r, t) {var a = r.length-1; while (r.charCodeAt (a-1) === 44) - a; devuelve E (e, r.substr (0, a), t / Math.pow (10,3 * (r.length-a)))} función C (r, a, n) {var i = a.replace (e, ""), s = a.length-i.length; devuelve E (r, i, n * Math.pow (10,2 * s) ) + t ("%", s)} función _ (e, r) {var t; var a = e.indexOf ("E") - e.indexOf (".") - 1; if (e.match (/ ^ # + 0.0E \ +0 $ /)) {if (r == 0) return "0.0E + 0"; else if (r <0) return "-" + _ (e, -r) ; var n = e.indexOf ("."); if (n === - 1) n = e.indexOf ("E"); var i = Math.floor (Math.log (r) * Math.LOG10E )% n; if (i <0) i + = n; t = (r / Math.pow (10, i)). toPrecision (a + 1 + (n + i)% n); if (! t.match (/ [Ee] /)) {var s = Math.floor (Math.log (r) * Math.LOG10E); if (t.indexOf (".") === - 1) t = t.charAt ( 0) + "." + T.substr (1) + "E +" + (st.length + i); de lo contrario t + = "E +" + (si); t = t.replace (/ \ + - /, " - ")} t = t.replace (/ ^ ([+ -]?) (\ d *) \. (\ d *) [Ee] /, función (e, r, t, a) {return r + t + a.substr (0, (n + i)% n) + "." + a.substr (i) + "E"})} else t = r.toExponential (a); if (e.match ( /E\+00$/)&&t.match(/e[+-font>\d$/))t=t.substr(0,t.length-1)+"0"+t.charAt(t.length -1); if (e.match (/ E \ - /) && t.match (/ e \ + /)) t = t.replace (/ e \ + /, "e"); devuelve t.reemplazar ("e", "E")} función T (e, s, l) {if (e.charCodeAt (0) === 40 &&! s.match (p)) {var o = s.replace (/ \ (* /, ""). replace (/ \) /, ""). replace (/ \) /, ""); if (l> = 0) devuelve T ("n", o, l); return "(" + T ("n", o, -l) + ")"} if (s.charCodeAt (s.length-1) === 44) return S (e, s, l); if ( s.indexOf ("%")! == - 1) return C (e, s, l); if (s.indexOf ("E")! == - 1) return _ (s, l); if ( s.charCodeAt (0) === 36) devuelve "$" + T (e, s.substr (s.charAt (1) == ""? 2: 1), l); var f; var h, b , w, k = Math.abs (l), y = l <0? "-": ""; if (s.match (/ ^ 00 + $ /)) devuelve y + a (k, s.length) ; if (s.match (/ ^ [#?] + $ /)) {f = "" + l; if (l === 0) f = ""; devuelve f.length> s.length? f: g (s.substr (0, s.length-f.length)) + f} if (h = s.match (c)) devuelve u (h, k, y); if (s.match (/ ^ # +0 + $ /)) devuelve y + a (k, s.length-s.indexOf ("0 ")); if (h = s.match (d)) {f = (" "+ l) .replace (/^([^\.font>+)$/,"$ 1." + G (h [ 1])). Replace (/\.$/,"."+ g (h [1])); f = f.replace (/ \. (\ D *) $ /, function (e, r) { return "." + r + t ("0", g (h [1]). length-r.length)}); return s.indexOf ("0.")! == - 1? f: f. reemplazar (/ ^ 0 \ ./, ".")} s = s.replace (/ ^ # + ([0.]) /, "$ 1"); if (h = s.match (/ ^ (0 * ) \. (# *) $ /)) {return y + ("" + k) .replace (/ \. (\ d * [1-9]) 0 * $ /, ". $ 1"). replace (/ ^ (-? \ d *) $ /, "$ 1."). reemplazar (/ ^ 0 \ ./, h [1] .length? "0.": ".")} if (h = s.match (/^#{1,3},##0(\.?)$/))return y + A ("" + k); if (h = s.match (/ ^ #, ## 0 \. ([# 0] * 0) $ /)) {return l <0? "-" + T (e, s, -l): A ("" + l) + "." + T ("0", h [1] .length)} if (h = s.match (/ ^ #, # *, # 0 /)) devuelve T (e, s.replace (/ ^ #, # *, /, ""), l); if (h = s.match (/ ^ ([0 #] +) (\\? - ([0 #] +)) + $ /)) {f = r (T (e, s.replace (/ [\\ -] / g, ""), l)); b = 0; return r (r (s.replace (/ \\ / g, "")). replace (/ [0 #] / g, función (e) {return b <f.length? f.charAt (b ++): e === "0"? "0": ""}))} if (s.match (m)) { f = T (e, "##########", l); devuelve "(" + f.substr (0,3) + ")" + f.substr (3,3) + " - "+ f.substr (6)} var x =" "; if (h = s.match (/ ^ ([# 0?] +) (?) \ / (?) ([# 0?] +) /)){b=Math.min(h[4font>.length,7);w=v(k,Math.pow(10,b)-1,false);f=""+y;x=E ("n", h [1], w [1]); if (x.charAt (x.length-1) == "") x = x.substr (0, x.length-1) + "0 "; f + = x + h [2] +" / "+ h [3]; x = i (w [2], b); if (x.length <h [4] .length) x = g (h [4] .substr (h [4] .length-x.length)) + x; f + = x; return f} if (h = s.match (/ ^ # ([# 0?] +) (?) \ / (?) ([# 0?] +) /)) {B = Math.min (Math.max (h [1] .length, h [4] .length), 7); w = v (k , Math.pow (10, b) -1, verdadero); devuelve y + (w [0] || (w [1]? "": "0 ")) +" "+ (w [1]? N (w [1], b) + h [2] +" / "+ h [3] + i (w [2], b): t ( "", 2 * b + 1 + h [2] .length + h [3] .length))} if (h = s.match (/ ^ [# 0?] + $ /)) {F = "" + l; if (s.length <= f.length) devuelve f; return g (s.substr (0, s.length-f.length)) + f} if (h = s.match (/ ^ ([ # 0] +) \. ([# 0] +) $ /)) {f = "" + l.toFixed (Math.min (h [2] .length, 10)). Replace (/ ([^ 0 ]) 0 + $ /, "$ 1"); b = f.indexOf ("."); Var F = s.indexOf (".") - b, O = s.length-f.length-F; return g (s.substr (0, F) + f + s.substr (s.length-O))} if (h = s.match (/ ^ 00,000 \. ([# 0] * 0) $ /)) {return l <0? "-" + T (e, s, -l): A ("" + l) .replace (/ ^ \ d, \ d {3} $ /, "0 $ &"). reemplazar (/ ^ \ d * $ /, función (e) {return "00," + (e.length <3? a (0,3-e.length): "") + e}) + "." + a (0, h [1] .length)} conmutador (es) {case "###, ###" :; case "##, ###" :; case "#, ###": var D = A (""+ k); return D! == "0"? y + D: ""; default: if (s.match (/ \. [0 #?] * $ /)) return T (e, s.slice ( 0, s.lastIndexOf (".")), L) + g (s.slice (s.lastIndexOf (".")));} Arrojar un nuevo error ("formato no compatible |" + s + "|")} return función F (e, r, t) {return (t | 0) === t? T (e, r, t): x (e, r, t)}} (); función T (e) {var r = []; var t = falso; for (var a = 0, n = 0; a <e.length; ++ a) switch (e.charCodeAt (a)) {case 34: t =! t; break ; caso 95:; caso 42:; caso 92: ++ a; pausa; caso 59: r [r.length] = e.substr (n, an); n = a + 1;} r [r.length] = e.substr (n); si (t === verdadero) arroja un nuevo error ("Formato |" + e + "| cadena sin terminar"); devuelve r} e._split = T; var F = / \ [[HhMmSs ] * \] /; función O (e) {var r = 0, t = "", a = ""; while (r <e.length) {switch (t = e.charAt (r)) {case " G ": if (c (e, r)) r + = 6; r ++; break; case '"': for (; e.charCodeAt (++ r)! == 34 && r <e.length;) ++ r; ++ r; break; case "\\": r + = 2; break; case "_": r + = 2; break; case "@": ++ r; break; case "B": ; caso "b": if (e.charAt (r + 1) === "1" || e.charAt (r + 1) === "2") devuelve verdadero; caso "M":; caso " D ":; caso" Y ":; caso" H ":; caso" S ":; caso" E ":; caso" m ":; caso" d ":; caso" y ":; caso" h " :; case "s":; case "e":; case "g": return true; case "A":; case "a": if (e.substr (r, 3) .toUpperCase () === "A / P") devuelve verdadero; if (e.substr (r, 5) .toUpperCase () === "AM / PM") devuelve verdadero; ++ r; break; case "[": a = t; while (e.charAt (r ++)! == "]" && r <e.length) a + = e.charAt (r); if (a.match (F)) return true; break; case "." :; case "0":; case "#": while (r <e.length &&("0 #?., E + -%". IndexOf (t = e.charAt (++ r))> - 1 || t == "\\" && e.charAt (r + 1) == "-" && "0 #". IndexOf (e.charAt (r + 2))> - 1)) {} break; case "?": While (e.charAt (++ r) === t) {} break; case "*": ++ r; if (e.charAt (r) == "" || e.charAt (r) == "*") ++ r; break; case "(":; case ") ": ++ r; break; case" 1 ":; case" 2 ":; case" 3 ":; case" 4 ":; case" 5 ":; case" 6 ":; case" 7 ":; case "8":; case "9": while (r <e.length && "0123456789" .indexOf (e.charAt (++ r))> - 1) {} break; case "": ++ r; break ; predeterminado: ++ r; break;}} return false} e.is_date = O; función D (e, r, t, a) {var n = [], i = "", s = 0, l = " ", o =" t ", f, h, u; var d =" H "; while (s <e.length) {switch (l = e.charAt (s)) {case" G ":if (! c (e, s)) arroja un nuevo error ("carácter no reconocido" + l + "en" + e); n [n.length] = {t: "G", v: "General"}; s + = 7; break; case '"': for (i =" "; (u = e.charCodeAt (++ s))! == 34 && s <e.length;) i + = String.fromCharCode (u); n [n .length] = {t: "t", v: i}; ++ s; break; case "\\": var p = e.charAt (++ s), v = p === "(" | | p === ")"? p: "t"; n [n.length] = {t: v, v: p}; ++ s; break; case "_": n [n.length] = {t: "t", v: ""}; s + = 2; break; case "@": n [n.length] = {t: "T", v: r}; ++ s; break; case "B":; caso "b": if (e.charAt (s + 1) === "1" || e.charAt (s + 1) === "2") {if (f == null ) {f = m (r, t, e.charAt (s + 1) === "2"); if (f == null) return ""} n [n.length] = {t: "X" , v: e.substr (s, 2)}; o = l; s + = 2; salto}; caso "M":; caso "D" :;case "Y":; case "H":; case "S":; case "E": l = l.toLowerCase (); case "m":; case "d":; case "y":; case "h":; caso "s":; caso "e":; caso "g": if (r <0) return ""; if (f == null) {f = m (r, t); if (f == null) return ""} i = l; while (++ s <e.length && e.charAt (s) .toLowerCase () === l) i + = l; if (l === "m" && o.toLowerCase () === "h") l = "M"; if (l === "h") l = d; n [n.length] = {t: l, v: i}; o = l; break; caso "A":; caso "a": var g = {t: l, v: l}; if (f == null) f = m (r, t); if (e.substr (s, 3) .toUpperCase () === "A / P") {if (f! = null) gv = fH> = 12? "P": "A"; gt = "T"; d = " h "; s + = 3} más if (e.substr (s, 5) .toUpperCase () ===" AM / PM ") {if (f! = null) gv = fH> = 12?" PM ": "AM"; gt = "T";s + = 5; d = "h"} else {gt = "t"; ++ s} if (f == null && g.t === "T") return ""; n [n.length] = g; o = l; break; case "[": i = l; while (e.charAt (s ++)! == "]" && s <e.length) i + = e.charAt (s); if (i.slice ( -1)! == "]") throw'unterminated "[" bloque: | '+ i + "|"; if (i.match (F)) {if (f == null) {f = m (r, t); if (f == null) return ""} n [n.length] = {t: "Z", v: i.toLowerCase ()}; o = i.charAt (1)} else if (i .indexOf ("$")> - 1) {i = (i.match (/ \ $ ([^ - \ [\]] *) /) || []) [1] || "$"; si (! O (e)) n [n.length] = {t: "t", v: i}} break; case ".": If (f! = Null) {i = l; while (++ s <e.length && (l = e.charAt (s)) === "0") i + = l; n [n.length] = {t: "s", v: i}; break}; case "0 ":; case" # ": i = l; while (++ s <e.length &&" 0 #?., E + -% ". indexOf (l = e.charAt (s))>-1 || l == "\\" && e.charAt (s + 1) == "-" && s <e.length-2 && "0 #". IndexOf (e.charAt (s + 2))> - 1 ) i + = l; n [n.length] = {t: "n", v: i}; break; case "?": i = l; while (e.charAt (++ s) === l) i + = l; n [n.length] = {t: l, v: i}; o = l; break; case "*": ++ s; if (e.charAt (s) == "" || e.charAt (s) == "*") ++ s; break; case "(":; case ")": n [n.length] = {t: a === 1? "t": l , v: l}; ++ s; break; caso "1":; caso "2":; ​​caso "3":; caso "4":; caso "5":; caso "6":; caso " 7 ":; caso" 8 ":; caso" 9 ": i = l; while (s <e.length &&" 0123456789 ".indexOf (e.charAt (++ s))> - 1) i + = e.charAt (s); n [n.length] = {t: "D", v: i}; break; case "": n [n.length] = {t: l, v: l}; ++ s; break; default: if (", $ - + / ():! ^ & '~ {} <>= € acfijklopqrtuvwxzP ".indexOf (l) === - 1) arrojar un nuevo error (" carácter no reconocido "+ l +" en "+ e); n [n.length] = {t:" t ", v: l} ; ++ s; break;}} var b = 0, w = 0, k; for (s = n.length-1, o = "t"; s> = 0; - s) {switch (n [ s] .t) {case "h":; case "H": n [s] .t = d; o = "h"; if (b <1) b = 1; break; case "s": if (k = n [s] .v.match (/ \. 0 + $ /)) w = Math.max (w, k [0] .length-1); if (b <3) b = 3; case "d":; case "y":; case "M":; case "e": o = n [s] .t; break; case "m": if (o === "s") {n [s] .t = "M"; if (b <2) b = 2} break; case "X": break; case "Z": if (b <1 && n [s] .v.match (/ [Hh ] /)) b = 1; if (b <2 && n [s] .v.match (/ [Mm] /)) b = 2; if (b <3 && n [s] .v.match (/ [Ss] / )) b = 3;}} conmutador (b) {caso 0: descanso; caso 1: if (fu> =. 5) {fu = 0; ++ fS} if (fS> = 60) {fS = 0; ++ fM} if (fM> = 60) {fM = 0;++ fH} break; caso 2: if (fu> =. 5) {fu = 0; ++ fS} if (fS> = 60) {fS = 0; ++ fM} break;} var y = "" , x; for (s = 0; s <n.length; ++ s) {switch (n [s] .t) {case "t":; case "T":; case "":; case "D ": break; case" X ": n [s] .v =" "; n [s] .t ="; "; break; case" d ":; case" m ":; case" y ":; caso "h":; caso "H":; caso "M":; caso "s":; caso "e":; caso "b":; caso "Z": n [s] .v = _ ( n [s] .t.charCodeAt (0), n [s] .v, f, w); n [s] .t = "t"; break; case "n":; case "(":; case "?": x = s + 1; while (n [x]! = nulo && ((l = n [x] .t) === "?" || l === "D" || (l = == "" || l === "t") && n [x + 1]! = nulo && (n [x + 1] .t === "?" || n [x + 1] .t == = "t" && n [x + 1] .v === "/") || n [s] .t === "("&& (l ===" "|| l ===" n "|| l ===") ") || l ===" t "&& (n [x] .v ===" /"||n[xfont>.v=== "" && n [x + 1]! = nulo && n [x + 1] .t == "?"))) {n [s] .v + = n [x ] .v; n [x] = {v: "", t: ";"}; ++ x} y + = n [s] .v; s = x-1; pausa; caso "G": n [ s] .t = "t"; n [s] .v = S (r, t); break;}} var C = "", A, T; if (y.length> 0) {if (y. charCodeAt (0) == 40) {A = r <0 && y.charCodeAt (0) === 45? -r: r; T = E ("(", y, A)} else {A = r <0 && a> 1? -R: r; T = E ("n", y, A); if (A <0 && n [0] && n [0] .t == "t") {T = T.substr (1); n [0] .v = "-" + n [0] .v}} x = T.length-1; var D = n.length; para (s = 0; s <n.length; ++ s) if (n [s]! = null && n [s] .t! = "t" && n [s] .v.indexOf (".")> - 1) {D = s; break} var M = n.length; if (D === n.length && T.indexOf ("E") === - 1) {for (s = n.length-1; s> = 0; - s) {if (n [s] == null || "n? (". IndexOf (n [s ] .t) === - 1) continuar; if (x> = n [s] .v.length-1) {x- = n [s] .v.length; n [s] .v = T. substr (x + 1, n [s] .v.length)} else if (x <0) n [s] .v = ""; else {n [s] .v = T.substr (0, x + 1); x = -1} n [s] .t = "t"; M = s} if (x> = 0 && M <n.length) n [M] .v = T.substr (0, x + 1 ) + n [M] .v} más si (D! == n.length && T.indexOf ("E") === - 1) {x = T.indexOf (".") - 1; for (s = D; s> = 0; - s) {if (n [s] == null || "n? (". IndexOf (n [s] .t) === - 1) continuar; h = n [ s] .v.indexOf (".")> - 1 && s === D? n [s] .v.indexOf (".") - 1: n [s] .v.length-1; C = n [ s] .v.substr (h + 1); para (; h> = 0; - h) {if (x> = 0 && (n [s] .v.charAt (h) === "0" | | n [s] .v.charAt (h) === "#")) C = T.charAt (x -) + C} n [s] .v = C; n [s] .t = " t "; M = s} if (x> = 0 && M <n.length) n [M] .v = T.substr (0, x + 1) + n [M] .v; x = T.indexOf (".") + 1; for (s = D; s <n.length; ++ s) {if (n [s] == null || "n? (". indexOf (n [s]. t) === - 1 && s! == D) continuar; h = n [s] .v.indexOf (".")> - 1 && s === D? n [s] .v.indexOf (".") +1: 0; C = n [s] .v.substr (0, h); para (; h <n [s] .v.length; ++ h) {if (x <T.length) C + = T.charAt (x ++)} n [s] .v = C; n [s] .t = "t"; M = s}}} para (s = 0; s <n.length; ++ s) if (n [s]! = nulo && "n (?". indexOf (n [s] .t)> - 1) {A = a> 1 && r <0 && s> 0 && n [s-1] .v === "-" ? -r: r; n [s] .v = E (n [s] .t, n [s] .v, A); n [s] .t = "t"} var P = ""; para (s = 0; s! == n.length; ++ s) if (n [s]! = null) P + = n [s] .v; return P} e._eval = D; var M = / \ [[= <>] /; var P = / \ [(= |> [=]? | <[> =]?) (-? \ d + (?: \. \ d *)?) \] /; función R (e, r) {if (r == null) return false; var t = parseFloat (r [2]); switch (r [1]) {case "=": if (e == t) return verdadero; descanso; caso ">":if (e> t) devuelve true; break; case "<": if (e <t) devuelve true; break; case "<>": if (e! = t) devuelve true; break; case "> =" : if (e> = t) devuelve true; break; case "<=": if (e <= t) devuelve true; break;} return false} función N (e, r) {var t = T (e) ; var a = t.length, n = t [a-1] .indexOf ("@"); if (a <4 && n> -1) - a; if (t.length> 4) arroja un nuevo error (" no puede encontrar el formato correcto para | "+ t.join (" | ") +" | "); if (typeof r! ==" number ") return [4, t.length === 4 || n> -1 ? t [t.length-1]: "@"]; switch (t.length) {case 1: t = n> -1? ["General", "General", "General", t [0]] : [t [0], t [0], t [0], "@"]; salto; caso 2: t = n> -1? [t [0], t [0], t [0], t [1]]: [t [0], t [1], t [0], "@"]; salto; caso 3: t = n> -1? [t [0], t [1], t [0], t [2]]: [t [0], t [1], t [2], "@"]; descanso; caso 4: descanso;} var i = r> 0? t [0]: r <0? t [1]: t [2]; if (t [0] .indexOf ("[") === - 1 && t [1] .indexOf ("[") === - 1) return [a, i]; if (t [0] .match (M)! = Null || t [1] .match (M)! = Null) {var s = t [0] .match (P); var l = t [1] .match (P); devuelve R (r, s)? [a, t [0]]: R (r, l)? [a , t [1]]: [a, t [s! = null && l! = null? 2: 1]]} return [a, i]} function I (e, r, t) {if (t == null) t = {}; var a = ""; switch (typeof e) {case "string": if (e == "m / d / aa" && t.dateNF) a = t.dateNF; si no a = e; break ; caso "número": if (e == 14 && t.dateNF) a = t.dateNF; si no a = (t.table! = null? t.table: p) [e]; break;} if (c (a , 0)) devuelve S (r, t); if (r instancia de fecha) r = k (r, t.date1904); var n = N (a, r); if (c (n [1])) return S (r, t); if (r === verdadero) r = "VERDADERO"; si no (r === falso) r = "FALSO"; si if (r === "" || r == null) return ""; return D (n [1], r, t, n [0])} function L (e, r) {if (typeof r! = "number") {r = + r || -1; para (var t = 0; t <392; ++ t) {if (p [t] == ​​undefined) {if (r <0) r = t; continuar} if (p [t] == ​​e) {r = t; break}} if (r <0) r = 391} p [r] = e; return r} e.load = L; e._table = p; e.get_table = function W () {return p}; e.load_table = function $ (e) {for (var r = 0; r! = 392; ++ r) if (e [r]! == undefined) L (e [r], r)}; e.init_table = d; e.format = I}; R (P); var N = {"Número general": "General", "Fecha general": P._table [22], "Fecha larga": "dddd, mmmm dd, aaaa", "Fecha media": P._table [15], "Fecha corta": P._table [14], "Tiempo largo": P._table [19], "Tiempo medio": P._table [18], "Tiempo corto": P._table [20], Moneda: '"$" #, ## 0.00 _); [Rojo] \\ ("$ "#, ## 0.00 \\) ', Fijo: P._table [2], Estándar: P._table [4], Porcentaje: P._table [10], Científico: P._table [11]," Sí / No ": '" Sí ";" Sí ";" No "; @ ', "Verdadero / Falso":' "Verdadero"; "Verdadero"; "Falso"; @ ', "Encendido / Apagado":' "Sí"; "Sí"; "No"; @ '}; var I = {5: '"$" #, ## 0 _); \\ ("$" #, ## 0 \\)', 6: '"$" #, ## 0 _); [Rojo] \\ ("$" #, ## 0 \\) ', 7:' "$" #, ## 0.00 _); \\ ("$" #, ## 0.00 \\) ', 8:' "$" #, ## 0.00 _); [Rojo] \\ ("$" #, ## 0.00 \\) ', 23: "General", 24: "General", 25: "General", 26: "General" , 27: "m / d / aa", 28: "m / d / aa", 29: "m / d / aa", 30: "m / d / aa", 31: "m / d / aa" , 32: "h: mm: ss", 33: "h: mm: ss", 34: "h: mm: ss", 35: "h: mm: ss", 36: "m / d / aa" , 41: '_ (* #, ## 0 _); _ (* (#, ## 0); _ (* "-" _); _ (@_)', 42: '_ ("$" * #, ## 0 _); _ ("$ "* (#, ## 0); _ (" $ "*" - "_); _ (@_) ', 43:' _ (* #, ## 0.00 _); _ (* (#, ## 0.00); _ (* "-" ?? _); _ (@_) ', 44:' _ ("$" * #, ## 0.00 _); _ ("$" * (#, # # 0.00); _ ("$" * "-" ?? _); _ (@_) ', 50: "m / d / aa", 51: "m / d / aa", 52: "m / d / aa ", 53:" m / d / aa ", 54:" m / d / aa ", 55:" m / d / aa ", 56:" m / d / aa ", 57:" m / d / aa ", 58:" m / d / aa ", 59:" 0 ", 60:" 0.00 ", 61:" #, ## 0 ", 62:" #, ## 0.00 ", 63: ' "$" #, ## 0 _); \\ ("$" #, ## 0 \\) ', 64:' "$" #, ## 0 _); [Rojo] \\ ("$" #, ## 0 \\) ', 65:' "$" #, ## 0.00 _); \\ ("$" #, ## 0.00 \\) ', 66:' "$" #, ## 0.00_ ); [Rojo] \\ ("$" #, ## 0.00 \\) ', 67: "0%", 68: "0.00%", 69: "#? /?", 70: "# ?? / ?? ", 71:" m / d / aa ", 72:" m / d / aa ", 73:" d-mmm-aa ", 74:" d-mmm ", 75:" mmm -aa ", 76:" h: mm ", 77:" h: mm: ss ", 78:" m / d / aa h: mm ", 79:" mm: ss ", 80:" [h]: mm: ss ", 81:" mmss.0 "}; var L = / [dD] + | [mM] + | [yYeE] + | [Hh] + | [Ss] + / g; función B (e) {var r = typeof e == "number"? P._table [e]: e; r = r.replace (L, "(\\ d +)"); return new RegExp ("^" + r + "$" )} función z (e, r, t) {var a = -1, n = -1, i = -1, s = -1, l = -1, o = -1; (r.match (L) || []). forEach (function (e, r) {var f = parseInt (t [r + 1], 10); switch (e.toLowerCase (). charAt (0)) {case "y": a = f; descanso; caso "d": i = f; descanso; caso "h": s = f; descanso; caso "s": o = f; descanso; caso "m": if (s> = 0) l = f; más n = f; descanso;}}); if (o> = 0 && l == - 1 && n> = 0) {l = n; n = -1} var f = ("" + (a> = 0? A:(nueva Fecha) .getFullYear ())). slice (-4) + "-" + ("00" + (n> = 1? n: 1)). slice (-2) + "-" + (" 00 "+ (i> = 1? I: 1)). Slice (-2); if (f.length == 7) f =" 0 "+ f; if (f.length == 8) f =" 20 "+ f; var c = (" 00 "+ (s> = 0? S: 0)). Slice (-2) +": "+ (" 00 "+ (l> = 0? L: 0) ) .slice (-2) + ":" + ("00" + (o> = 0? o: 0)). slice (-2); if (s == - 1 && l == - 1 && o == - 1 ) return f; if (a == - 1 && n == - 1 && i == - 1) return c; return f + "T" + c} var W = verdadero; var U; (function (e) {e (U = { })}) (function (e) {e.version = "1.2.0"; function r () {var e = 0, r = new Array (256); for (var t = 0; t! = 256; ++ t) {e = t; e = e & 1? -306674912 ^ e >>> 1: e >>> 1; e = e & 1? -306674912 ^ e >>> 1: e >>> 1; e = e & 1 ? -306674912 ^ e >>> 1: e >>> 1; e = e & 1? -306674912 ^ e >>> 1: e >>> 1; e = e &1? -306674912 ^ e >>> 1: e >>> 1; e = e & 1? -306674912 ^ e >>> 1: e >>> 1; e = e & 1? -306674912 ^ e >>> 1: e >>> 1; e = e & 1? -306674912 ^ e >>> 1: e >>> 1; r [t] = e} return typeof Int32Array! == "undefined"? New Int32Array (r): r} var t = r (); función a (e, r) {var a = r ^ -1, n = e.length-1; for (var i = 0; i <n;) {a = a >>> 8 ^ t [(a ^ e.charCodeAt (i ++)) & 255]; a = a >>> 8 ^ t [(a ^ e.charCodeAt (i ++)) & 255]} if (i === n) a = a >>> 8 ^ t [(a ^ e.charCodeAt (i)) & 255]; devuelve una función ^ -1} n (e, r) {if (e.length> 1e4) devuelve i (e, r); var a = r ^ -1, n = e.length-3; for (var s = 0; s <n;) {a = a >>> 8 ^ t [(a ^ e [s ++]) & 255]; a = a >>> 8 ^ t [(a ^ e [s ++]) & 255]; a = a >>> 8 ^ t [(a ^ e [s ++]) & 255]; a = a >>> 8 ^ t [(a ^ e [s ++]) & 255]} while (s <n + 3) a = a >>> 8 ^ t [(a ^ e [s ++]) & 255]; devuelve una función ^ -1} i (e, r) {var a = r ^ -1, n = e.longitud-7; para (var i = 0; i <n;) {a = a >>> 8 ^ t [(a ^ e [i ++]) & 255]; a = a >>> 8 ^ t [(a ^ e [i ++]) & 255]; a = a >>> 8 ^ t [(a ^ e [i ++]) & 255]; a = a >>> 8 ^ t [(a ^ e [i ++]) & 255] ; a = a >>> 8 ^ t [(a ^ e [i ++]) & 255]; a = a >>> 8 ^ t [(a ^ e [i ++]) & 255]; a = a >>> 8 ^ t [(a ^ e [i ++]) & 255]; a = a >>> 8 ^ t [(a ^ e [i ++]) & 255]} while (i <n + 7) a = a >>> 8 ^ t [(a ^ e [i ++]) & 255]; devuelve a ^ -1} función s (e, r) {var a = r ^ -1; para (var n = 0, i = e.length, s , l; n <i;) {s = e.charCodeAt (n ++); if (s <128) {a = a >>> 8 ^ t [(a ^ s) & 255]} más if (s <2048) {a = a >>> 8 ^ t [(a ^ (192 | s >> 6 & 31)) & 255]; a = a >>> 8 ^ t [(a ^ (128 | s & 63)) & 255]} más si (s> = 55296 && s <57344) {s = (s & 1023) +64; l = e.charCodeAt (n ++) & 1023; a = a >>> 8 ^ t [(a ^ (240 | s >> 8 & 7)) & 255 ]; a = a >>> 8 ^ t [(a ^ (128 | s >> 2 y 63)) & 255];a = a >>> 8 ^ t [(a ^ (128 | l >> 6 & 15 | (s & 3) << 4)) & 255]; a = a >>> 8 ^ t [(a ^ (128 | l & 63) ) & 255]} else {a = a >>> 8 ^ t [(a ^ (224 | s >> 12 & 15)) & 255]; a = a >>> 8 ^ t [(a ^ (128 | s >> 6 y 63)) & 255]; a = a >>> 8 ^ t [(a ^ (128 | sy 63)) & 255]}} devuelve a ^ -1} e.table = t; e.bstr = a; e.buf = n; e.str = s}); var j = función Tl () {var e = {}; e.version = "1.1.3"; función r (e, r) {var t = e.split ( "/"),a=r.split("/");for(var n = 0, i = 0, s = Math.min (t.length, a.length); n <s; ++ n) {if (i = t [n] .length-a [n] .length) devuelve i; if (t [n]! = a [n]) devuelve t [n] <a [n]? - 1: 1 } return t.length-a.length} función t (e) {if (e.charAt (e.length-1) == "/") return e.slice (0, -1) .indexOf ("/" ) === - 1? E: t (e.slice (0, -1)); var r = e.lastIndexOf ("/"); devuelve r === - 1? E: e.slice (0, r + 1)} función a (e) {if (e.charAt (e.length-1) == "/ ") devuelve a (e.slice (0, -1)); var r = e.lastIndexOf (" / "); devuelve r === - 1? e: e.slice (r + 1)} función n (e, r) {if (typeof r === "string") r = new Date (r); var t = r.getHours (); t = t << 6 | r.getMinutes (); t = t << 5 | r.getSeconds () >>> 1; e._W (2, t); var a = r.getFullYear () - 1980; a = a << 4 | r.getMonth () + 1; a = a << 5 | r.getDate (); e._W (2, a)} función i (e) {var r = e._R (2) & 65535; var t = e._R (2) & 65535; var a = nueva Fecha; var n = t & 31; t >>> = 5; var i = t & 15; t >>> = 4; a.setMilliseconds (0); a.setFullYear (t + 1980); a.setMonth (i -1); a.setDate (n); var s = r & 31; r >>> = 5; var l = r & 63; r >>> = 6; a.setHours (r); a.setMinutes (l); a .setSeconds (s << 1); devuelve una} función s (e) {Xr (e, 0); var r = {}; var t = 0; while (el <= e.length-4) {var a = e._R (2); var n = e._R (2), i = e.l + n; var s = {}; interruptor (a) {caso 21589: {t = e._R (1); if (t & 1) s.mtime = e._R (4);if (n> 5) {if (t & 2) s.atime = e._R (4);
if (t & 4) s.ctime = e._R (4)} if (s.mtime) s.mt = new Date (s.mtime * 1e3)} break;} el = i; r [a] = s} return r} var l; función o () {return l || (l = require ("fs"))} function f (e, r) {if (e [0] == 80 && e [1] == 75) return Ae (e, r); if (e.length <512) arroja un nuevo error ("tamaño de archivo CFB" + e.length + "<512"); var t = 3; var a = 512; var n = 0; var i = 0; var s = 0; var l = 0; var o = 0; var f = []; var p = e.slice (0,512); Xr (p, 0); var m = c (p); t = m [0]; interruptor (t) {caso 3: a = 512; descanso; caso 4: a = 4096; descanso; caso 0: si (m [1] == 0) devuelve Ae (e, r) ; predeterminado: lanzar un nuevo error ("Versión principal: se esperaba 3 o 4 vieron" + t);} if (a! == 512) {p = e.slice (0, a); Xr (p, 28)} var b = e.slice (0, a); h (p, t); var w = p._R (4, "i"); if (t === 3 && w! == 0) arroja un nuevo error ("# Sectores de directorio: Se esperaba 0 saw "+ w); p.l + = 4; s = p._R (4," i "); p.l + = 4; p.chk (" 00100000 "," Tamaño de corte de mini flujo:"); l = p._R (4," i "); n = p._R (4," i "); o = p._R (4," i "); i = p._R (4, "i"); para (var y = -1, x = 0; x <109; ++ x) {y = p._R (4, "i"); if (y <0) break; f [x ] = y} var S = u (e, a); v (o, i, S, a, f); var C = g (S, s, f, a); C [s] .name = "! Directorio "; if (n> 0 && l! == I) C [l] .name ="! MiniFAT "; C [f [0]]. Name ="! FAT "; C.fat_addrs = f; C.ssz = a; var _ = {}, A = [], E = [], T = []; k (s, C, S, A, n, _, E, l); d (E, T, A) ; A.shift (); var F = {FileIndex: E, FullPaths: T}; if (r && r.raw) F.raw = {header: b, sector: S}; return F} function c (e) {if (e [el] == 80 && e [e.l + 1] == 75) return [0,0]; e.chk (L, "Firma de encabezado:"); e.l + = 16; var r = e. _R (2, "u"); devuelve [e._R (2, "u"), r]} función h (e, r) {var t = 9; e.l + = 2; interruptor (t = e. _R (2)) {caso 9: si (r! = 3) arroja un nuevo error ("Cambio de sector: se esperaba 9 vio" + t); descanso; caso 12: si (r! = 4) arroja un nuevo error ("Cambio de sector: se esperaba 12 saw "+ t); pausa; valor predeterminado: lanzar un nuevo error (" Cambio de sector: Se esperaba 9 o 12 vio "+ t);} e.chk (" 0600 "," Mini Sector Shift: "); e.chk ("000000000000", "Reservado:")} función u (e, r) {var t = Math.ceil (e.length / r) -1; var a = []; for (var n = 1 ; n <t; ++ n) a [n-1] = e.slice (n * r, (n + 1) * r); a [t-1] = e.slice (t * r); retorno a} función d (e, r, t) {var a = 0, n = 0, i = 0, s = 0, l = 0, o = t.length; var f = [], c = []; para (; a <o; ++ a) {f [a] = c [a] = a; r [a] = t [a]} para (; l <c.length; ++ l) {a = c [l]; n = e [a] .L; i = e [a] .R; s = e [a] .C; if (f [a] === a) {if (n! == -1 && f [n]! == n) f [a] = f [n]; if (i! == - 1 && f [i]! == i) f [a] = f [i]} if (s! == - 1) f [s] = a; if (n! == - 1 && a! = F [a]) {f [n] = f [a]; if (c.lastIndexOf (n) <l) c .push (n)} if (i! == - 1 && a! = f [a]) {f [i] = f [a]; if (c.lastIndexOf (i) <l) c.push (i)} } para (a = 1; a <o; ++ a) if (f [a] === a) {if (i! == - 1 && f [i]! == i) f [a] = f [ yo];si no (n! == - 1 && f [n]! == n) f [a] = f [n]} para (a = 1; a <o; ++ a) {if (e [a] .type === 0) continuar; l = a; if (l! = F [l]) do {l = f [l]; r [a] = r [l] + "/" + r [a]} while (l! == 0 && - 1! == f [l] && l! = f [l]); f [a] = - 1} r [0] + = "/"; para (a = 1; a < o; ++ a) {if (e [a] .type! == 2) r [a] + = "/"}} función p (e, r, t) {var a = e.start, n = e.size; var i = []; var s = a; while (t && n> 0 && s> = 0) {i.push (r.slice (s * N, s * N + N)); n- = N; s = Br (t, s * 4)} if (i.length === 0) devuelve Yr (0); devuelve O (i) .slice (0, e.size)} función v (e, r, t , a, n) {var i = I; if (e === I) {if (r! == 0) arroja un nuevo error ("cadena DIFAT más corta de lo esperado")} else if (e! == - 1 ) {var s = t [e], l = (a >>> 2) -1; if (! s) return; for (var o = 0; o <l; ++ o) {if ((i = Br (s, o * 4)) === I) break; n.push (i)} v (Br (s, a-4), r-1, t, a, n)}} función m (e , r, t, a, n) {var i = [], s = []; if (! n) n = []; var l = a-1, o = 0, f = 0; for (o = r; o> = 0;) {n [o] = verdadero; i [i.length] = o; s.push (e [o]);var c = t [Math.floor (o * 4 / a)]; f = o * 4 & l; if (a <4 + f) arroja un nuevo error ("límite de FAT cruzado:" + o + "4" + a); if (! e [c]) break; o = Br (e [c], f)} return {nodos: i, data: dr ([s])}} function g (e, r, t, a) { var n = e.length, i = []; var s = [], l = [], o = []; var f = a-1, c = 0, h = 0, u = 0, d = 0 ; para (c = 0; c <n; ++ c) {l = []; u = c + r; if (u> = n) u- = n; if (s [u]) continuar; o = []; para (h = u; h> = 0;) {s [h] = verdadero; l [l.length] = h; o.push (e [h]); var p = t [Math.floor (h * 4 / a)]; d = h * 4 & f; if (a <4 + d) arroja un nuevo error ("límite de FAT cruzado:" + h + "4" + a); if (! e [p]) break; h = Br (e [p], d)} i [u] = {nodos: l, datos: dr ([o])}} return i} función k (e, r, t, a, n, i, s, l) {var o = 0, f = a.length? 2: 0; var c = r [e] .data; var h = 0, u = 0, d; for (; h <c. longitud; h + = 128) {var v = c.slice (h, h + 128); Xr (v, 64); u = v._R (2); d = vr (v, 0, uf); a. push (d); var g = {nombre: d, tipo: v._R (1), color: v._R (1), L: v._R (4, "i"), R: v._R ( 4, "i"), C: v._R (4, "i "), clsid: v._R (16), estado: v._R (4," i "), inicio: 0, tamaño: 0}; var b = v._R (2) + v._R (2 ) + v._R (2) + v._R (2); if (b! == 0) g.ct = y (v, vl-8); var w = v._R (2) + v._R (2) + v._R (2) + v._R (2); if (w! == 0) g.mt = y (v, vl-8); g.start = v._R (4, " i "); g.size = v._R (4," i "); if (g.size <0 && g.start <0) {g.size = g.type = 0; g.start = I; g. name = ""} if (g.type === 5) {o = g.start; if (n> 0 && o! == I) r [o] .name = "! StreamData"} más if (g.size > = 4096) {g.storage = "fat"; if (r [g.start] === undefined) r [g.start] = m (t, g.start, r.fat_addrs, r.ssz); r [g.start] .name = g.name; g.content = r [g.start] .data.slice (0, g.size)} else {g.storage = "minifat"; if (g.size <0) g.size = 0; si no (o! == I && g.start! == I && r [o]) {g.content = p (g, r [o] .data, (r [l] || {}). data)}} if (g.content) Xr (g.content, 0); i [d] = g; s.push (g)}} función y (e, r) {return new Date ( (Lr (e, r + 4) / 1e7 * Matemáticas.pow (2,32) + Lr (e, r) / 1e7-11644473600) * 1e3)} función x (e, r) {o (); devuelve f (l.readFileSync (e), r)} función A ( e, r) {switch (r && r.type || "base64") {case "file": return x (e, r); case "base64": return f (_ (b.decode (e)), r) ; case "binary": return f (_ (e), r);} return f (e, r)} función E (e, r) {var t = r || {}, a = t.root || "Entrada raíz"; if (! E.FullPaths) e.FullPaths = []; if (! E.FileIndex) e.FileIndex = []; if (e.FullPaths.length! == e.FileIndex.length) throw nuevo error ("estructura CFB inconsistente"); if (e.FullPaths.length === 0) {e.FullPaths [0] = a + "/"; e.FileIndex [0] = {name: a, type: 5 }} if (t.CLSID) e.FileIndex [0] .clsid = t.CLSID; T (e)} función T (e) {var r = "? Sh33tJ5"; if (j.find (e, "/ "+ r)) return; var t = Yr (4); t [0] = 55; t [1] = t [3] = 50; t [2] = 54; e.FileIndex.push ({nombre: r, tipo: 2, contenido: t, tamaño: 4, L: 69, R: 69, C: 69}); e.FullPaths.push (e.FullPaths [0] + r); F (e)} función F (e, n) {E (e); var i = false, s = false; for (var l = e.FullPaths.length-1; l> = 0; - l) {var o = e.FileIndex [l]; switch (o.type) {case 0: if (s) i = true; else {e.FileIndex.pop (); e.FullPaths. pop ()} break; caso 1:; caso 2:; caso 5: s = verdadero; if (isNaN (oR * oL * oC)) i = verdadero; if (oR> -1 && o.L> -1 && o.R = = oL) i = verdadero; salto; predeterminado: i = verdadero; descanso;}} if (! i &&! n) return; var f = new Date (1987,1,19), c = 0; var h = [] ; for (l = 0; l <e.FullPaths.length; ++ l) {if (e.FileIndex [l] .type === 0) continuar; h.push ([e.FullPaths [l], e .FileIndex [l]])} for (l = 0; l <h.length; ++ l) {var u = t (h [l] [0]); s = false; for (c = 0; c <h.length; ++ c) if (h [c] [0] === u) s = true; if (! s) h.push ([u, {name: a (u) .replace (" /",""),type:1,clsid:z,ct:f,mt:f,content:null}font>)}h.sort(function(e,t){return r (e [0], t [0])}); e.FullPaths = []; e.FileIndex = []; for (l = 0; l <h.length; ++ l) {e.FullPaths [l] = h [l] [ 0] e.FileIndex [l] = h [l] [1]} para (l = 0; l <h.length; ++ l) {var d = e.FileIndex [l]; var p = e.FullPaths [l]; d.name = a (p) .replace ("/", ""); dL = dR = dC = - (d.color = 1); d.size = d.content? d.content.length: 0; d.start = 0; d.clsid = d.clsid || z; if (l === 0) {dC = h.length> 1? 1: -1; d.size = 0; d.type = 5 } else if (p.slice (-1) == "/") {for (c = l + 1; c <h.length; ++ c) if (t (e.FullPaths [c]) == p ) break; dC = c> = h.length? -1: c; for (c = l + 1; c <h.length; ++ c) if (t (e.FullPaths [c]) == t ( p)) break; dR = c> = h.length? -1: c; d.type = 1} else {if (t (e.FullPaths [l + 1] || "") == t (p) ) dR = l + 1; d.type = 2}}} función P (e, r) {var t = r || {}; F (e); if (t.fileType == "zip") devuelve Te (e, t); var a = función (e) {var r = 0, t = 0; para (var a = 0; a <e.FileIndex.length; ++ a) {var n = e.FileIndex [ a]; if (! n.content) continue; var i = n.content.length; if (i> 0) {if (i <4096) r + = i + 63 >> 6; else t + = i + 511> > 9}} var s = e.FullPaths.longitud + 3 >> 2; var l = r + 7 >> 3; var o = r + 127 >> 7; var f = l + t + s + o; var c = f + 127 >> 7; var h = c <= 109? 0: Math.ceil ((c-109) / 127); while (f + c + h + 127 >> 7> c) h = ++ c <= 109? 0: Math.ceil ((c-109) / 127); var u = [1, h, c, o, s, t, r, 0]; e.FileIndex [0] .size = r << 6; u [7] = (e.FileIndex [0] .start = u [0] + u [1] + u [2] + u [3] + u [4] + u [5]) + (u [6] +7 >> 3); devuelve u} (e); var n = Yr (a [7] << 9); var i = 0, s = 0; {for (i = 0; i <8; ++ i) n. _W (1, B [i]); para (i = 0; i <8; ++ i) n._W (2,0); n._W (2,62); n._W (2,3) ; n._W (2,65534); n._W (2,9); n._W (2,6); para (i = 0; i <3; ++ i) n._W (2,0) ; n._W (4,0); n._W (4, a [2]); n._W (4, a [0] + a [1] + a [2] + a [3] -1) ; n._W (4,0); n._W (4,1 << 12); n._W (4, a [3]? a [0] + a [1] + a [2] -1: I); n._W (4, a [3]); n._W (-4, a [1]? A [0] -1: I); n._W (4, a [1]); para (i = 0; i <109; ++ i) n._W (-4, i <a [2]? a [1] + i: -1)} if (a [1]) {for (s = 0; s <a [1]; ++ s) {para (; i <236 + s * 127; ++ i) n._W (-4, i <a [2]? A [1] + i: -1); n._W (-4, s === a [1] -1? I:s + 1)}} var l = función (e) {para (s + = e; i <s-1; ++ i) n._W (-4, i + 1); if (e) {++ i ; n._W (-4, I)}}; s = i = 0; para (s + = a [1]; i <s; ++ i) n._W (-4, W.DIFSECT); para ( s + = a [2]; i <s; ++ i) n._W (-4, W.FATSECT); l (a [3]); l (a [4]); var o = 0, f = 0; var c = e.FileIndex [0]; for (; o <e.FileIndex.length; ++ o) {c = e.FileIndex [o]; if (! C.content) continue; f = c. content.length; if (f <4096) continue; c.start = s; l (f + 511 >> 9)} l (a [6] +7 >> 3); while (nl & 511) n._W (- 4, W.ENDOFCHAIN); s = i = 0; para (o = 0; o <e.FileIndex.length; ++ o) {c = e.FileIndex [o]; if (! C.content) continuar; f = c.content.length; if (! f || f> = 4096) continue; c.start = s; l (f + 63 >> 6)} while (nl & 511) n._W (-4, W. ENDOFCHAIN); for (i = 0; i <a [4] << 2; ++ i) {var h = e.FullPaths [i]; if (! H || h.length === 0) {for (o = 0; o <17; ++ o) n._W (4,0); para (o = 0; o <3; ++ o) n._W (4, -1); para (o = 0; o <12; ++ o) n._W (4,0); continuar} c = e.FileIndex [i]; if (i === 0) c.start = c.size? C.start- 1: yo;var u = i === 0 && t.root || c.name; f = 2 * (u.length + 1); n._W (64, u, "utf16le"); n._W (2, f); n._W (1, c.type); n._W (1, c.color); n._W (-4, cL); n._W (-4, cR); n._W (-4, cC ); if (! c.clsid) para (o = 0; o <4; ++ o) n._W (4,0); si no n._W (16, c.clsid, "hex"); n. _W (4, c. Estado || 0); n._W (4,0); n._W (4,0); n._W (4,0); n._W (4,0); n. _W (4, c.start); n._W (4, c.size); n._W (4,0)} para (i = 1; i <e.FileIndex.length; ++ i) {c = e.FileIndex [i]; if (c.size> = 4096) {nl = c.start + 1 << 9; for (o = 0; o <c.size; ++ o) n._W (1, c.contenido [o]); para (; o & 511; ++ o) n._W (1,0)}} para (i = 1; i <e.FileIndex.length; ++ i) {c = e. FileIndex [i]; if (c.size> 0 && c.size <4096) {for (o = 0; o <c.size; ++ o) n._W (1, c.content [o]); for ( ; o & 63; ++ o) n._W (1,0)}} while (nl <n.length) n._W (1,0); return n} función R (e, r) {var t = e. FullPaths.map (function (e) {return e.toUpperCase ()}); var a = t.map (function (e) {var r = e.split ("/");return r [r.length- (e.slice (-1) == "/"? 2: 1)]}); var n = false; if (r.charCodeAt (0) === 47) {n = verdadero; r = t [0] .slice (0, -1) + r} más n = r.indexOf ("/")! == - 1; var i = r.toUpperCase (); var s = n = == verdadero? t.indexOf (i): a.indexOf (i); if (s! == - 1) devuelve e.FileIndex [s]; var l =! i.match (M); i = i. reemplace (D, ""); if (l) i = i.replace (M, "!"); for (s = 0; s <t.length; ++ s) {if ((l? t [s ] .replace (M, "!"): t [s]). replace (D, "") == i) return e.FileIndex [s]; if ((l? a [s] .replace (M, "!"): a [s]). replace (D, "") == i) return e.FileIndex [s]} return null} var N = 64; var I = -2; var L = "d0cf11e0a1b11ae1" ; var B = [208,207,17,224,161,177,26,225]; var z = "00000000000000000000000000000000"; var W = {MAXREGSECT: -6, DIFSECT: -4, FATSECT: -3, ENDOFCHAIN: I, FREESECT: -1, HEADER_SIGNATURE: L , HEADER_MINOR_VERSION: "3e00", MAXREGSID: -6, NOSTREAM: -1, HEADER_CLSID: z,EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]}; function $ (e, r, t) {o (); var a = P (e, t); l.writeFileSync (r, a)} función H (e) {var r = new Array (e.length); for (var t = 0; t <e.length; ++ t) r [t] = String.fromCharCode (e [t]); devuelve r.join ("")} función V (e, r) {var t = P (e, r); switch (r && r.type) {case "file": o (); l.writeFileSync (r.filename, t); return t; case "binary": return H (t); case "base64": return b.encode (H (t));} return t} var X; función G (e) {try {var r = e.InflateRaw; var t = new r; t._processChunk (new Uint8Array ([3,0]), t._finishFlushFlag); if (t.bytesRead) X = e; de ​​lo contrario, arroje un nuevo error ("zlib no expone bytesRead")} catch (a) {console.error ("no puede usar zlib nativo:" + (a.message || a))}} función Y (e, r ) {if (! X) devuelve Ce (e, r); var t = X.InflateRaw;var a = new t; var n = a._processChunk (e.slice (el), a._finishFlushFlag); e.l + = a.bytesRead; return n} función J (e) {return X? X.deflateRawSync (e ): ue (e)} var Z = [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]; var q = [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258] ; var K = [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385 , 24577]; función Q (e) {var r = (e << 1 | e << 11) & 139536 | (e << 5 | e << 15) & 558144; return (r >> 16 | r >> 8 | r) & 255} var ee = typeof Uint8Array! == "undefined"; var re = ee? new Uint8Array (1 << 8): []; for (var te = 0; te <1 << 8; ++ te) re [te] = Q (te); función ae (e, r) {var t = re [e & 255]; if (r <= 8) devuelve t >>> 8-r; t = t << 8 | re [e >> 8 & 255]; if (r <= 16) devuelve t >>> 16-r; t = t << 8 | re [e >> 16 &255]; return t >>> 24-r} función ne (e, r) {var t = r & 7, a = r >>> 3; return (e [a] | (t <= 6? 0: e [ a + 1] << 8)) >>> t & 3} función es decir (e, r) {var t = r & 7, a = r >>> 3; return (e [a] | (t <= 5? 0: e [a + 1] << 8)) >>> t & 7} función se (e, r) {var t = r & 7, a = r >>> 3; return (e [a] | (t <= 4? 0: e [a + 1] << 8)) >>> t & 15} función le (e, r) {var t = r & 7, a = r >>> 3; return (e [a] | (t <= 3? 0: e [a + 1] << 8)) >>> t & 31} función oe (e, r) {var t = r & 7, a = r >>> 3; return (e [a] | (t <= 1? 0: e [a + 1] << 8)) >>> t & 127} función fe (e, r, t) {var a = r & 7, n = r >>> 3, i = (1 < <t) -1; var s = e [n] >>> a; if (t <8-a) devuelve s & i; s | = e [n + 1] << 8-a; if (t <16- a) devuelve s & i; s | = e [n + 2] << 16-a; if (t <24-a) devuelve s & i; s | = e [n + 3] << 24-a; devuelve s & i} función ce (e, r) {var t = e.length,a = 2 * t> r? 2 * t: r + 5, n = 0; if (t> = r) devuelve e; if (w) {var i = C (a); if (e.copy) e .copy (i); else for (; n <e.length; ++ n) i [n] = e [n]; return i} else if (ee) {var s = new Uint8Array (a); if ( s.set) s.set (e); más para (; n <e.length; ++ n) s [n] = e [n]; return s} e.length = a; return e} función he ( e) {var r = nueva matriz (e); for (var t = 0; t <e; ++ t) r [t] = 0; return r} var ue = function () {var e = function () {función de retorno e (r, t) {var a = 0; while (a <r.length) {var n = Math.min (65535, r.length-a); var i = a + n == r. longitud; t._W (1, + i); t._W (2, n); t._W (2, ~ n & 65535); mientras que (n--> 0) t [t.l ++] = r [a ++] } return tl}} (); return function (r) {var t = Yr (50 + Math.floor (r.length * 1.1)); var a = e (r, t); return t.slice (0, a)}} (); función de (e, r, t) {var a = 1, n = 0, i = 0, s = 0, l = 0, o = e.length; var f = ee? new Uint16Array (32): él (32); para (i = 0; i <32; ++ i) f [i] = 0; para (i = o; i <t; ++ i) e [i] = 0; o = e.length; var c = ee? New Uint16Array (o): he (o); for (i = 0; i <o;++ i) {f [n = e [i]] ++; if (a <n) a = n; c [i] = 0} f [0] = 0; for (i = 1; i <= a; ++ i) f [i + 16] = l = l + f [i-1] << 1; para (i = 0; i <o; ++ i) {l = e [i]; si (l! = 0) c [i] = f [l + 16] ++} var h = 0; para (i = 0; i <o; ++ i) {h = e [i]; if (h ! = 0) {l = ae (c [i], a) >> ah; para (s = (1 << a + 4-h) -1; s> = 0; - s) r [l | s << h] = h & 15 | i << 4}} devuelve a} var pe = ee? new Uint16Array (512): he (512); var ve = ee? new Uint16Array (32): he (32); if (! ee) {for (var me = 0; me <512; ++ me) pe [me] = 0; for (me = 0; me <32; ++ me) ve [me] = 0} (función () {var e = []; var r = 0; para (; r <32; r ++) e.push (5); de (e, ve, 32); var t = []; r = 0; para (; r <= 143; r ++) t.push (8); para (; r <= 255; r ++) t.push (9); para (; r <= 279; r ++) t.push (7); para (; r <= 287; r ++) t.push (8); de (t, pe, 288)}) (); var ge = ee? new Uint16Array (32768): he (32768); var be = ee ? new Uint16Array (32768): he (32768); var we = ee? new Uint16Array (128): he (128); var ke = 1, ye = 1; función xe (e, r) {var t = le ( e, r) +257; r + = 5; var a = le (e, r) +1;r + = 5; var n = se (e, r) +4; r + = 4; var i = 0; var s = ee? new Uint8Array (19): he (19); var l = [0,0,0 , 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]; var o = 1; var f = ee? New Uint8Array (8): he (8); var c = ee? new Uint8Array (8): he (8); var h = s.length; for (var u = 0; u <n; ++ u) {s [Z [u] ] = i = es decir (e, r); if (o <i) o = i; f [i] ++; r + = 3} var d = 0; f [0] = 0; para (u = 1; u <= o; ++ u) c [u] = d = d + f [u-1] << 1; para (u = 0; u <h; ++ u) if ((d = s [u ])! = 0) l [u] = c [d] ++; var p = 0; para (u = 0; u <h; ++ u) {p = s [u]; if (p! = 0) {d = re [l [u]] >> 8-p; para (var v = (1 << 7-p) -1; v> = 0; - v) nosotros [d | v << p] = p & 7 | u << 3}} var m = []; o = 1; para (; m.length <t + a;) {d = we [oe (e, r)]; r + = d & 7; interruptor (d >>> = 3) {caso 16: i = 3 + ne (e, r); r + = 2; d = m [m.length-1]; while (i--> 0) m.push (d); descanso; caso 17: i = 3 + es decir (e, r); r + = 3; mientras que (i--> 0) m.push (0); descanso; caso 18: i = 11 + oe ( e, r); r + = 7; while (i--> 0) m.push (0); break; default: m.push (d); if (o <d) o = d; break;}} var g = m.slice (0, t), b = m.rebanada (t); para (u = t; u <286; ++ u) g [u] = 0; para (u = a; u <30; ++ u) b [u] = 0; ke = de (g, ge, 286); ye = de (b, be, 30); return r} función Se (e, r) {if (e [0] == 3 &&! (e [1] & 3)) {return [S (r), 2]} var t = 0; var a = 0; var n = C (r? R: 1 << 18); var i = 0; var s = n.length >>> 0; var l = 0, o = 0; while ((a & 1) == 0) {a = ie (e, t); t + = 3; if (a >>> 1 == 0) {if (t & 7) t + = 8- (t & 7); var f = e [t >>> 3] | e [(t >>> 3) +1] << 8; t + = 32; if (! R && s <i + f) {n = ce (n, i + f); s = n.length} if (typeof e.copy === "function") {e.copy (n, i, t >>> 3, (t >>> 3) + f); i + = f; t + = 8 * f} más mientras que (f--> 0) {n [i ++] = e [t >>> 3]; t + = 8} continuar} else if (a >> > 1 == 1) {l = 9; o = 5} más {t = xe (e, t); l = ke; o = ye} if (! R && s <i + 32767) {n = ce (n, i + 32767); s = n.length} para (;;) {var c = fe (e, t, l); var h = a >>> 1 == 1? pe [c]: ge [c] ; t + = h & 15; h >>> = 4; if ((h >>> 8 & 255) === 0) n [i ++] = h;sino if (h == 256) break; else {h- = 257; var u = h <8? 0: h-4 >> 2; if (u> 5) u = 0; var d = i + q [ h]; if (u> 0) {d + = fe (e, t, u); t + = u} c = fe (e, t, o); h = a >>> 1 == 1? ve [c ]: be [c]; t + = h & 15; h >>> = 4; var p = h <4? 0: h-2 >> 1; var v = K [h]; if (p> 0) {v + = fe (e, t, p); t + = p} if (! r && s <d) {n = ce (n, d); s = n.length} while (i <d) {n [i] = n [iv]; ++ i}}}} return [r? n: n.slice (0, i), t + 7 >>> 3]} función Ce (e, r) {var t = e.slice ( el || 0); var a = Se (t, r); e.l + = a [1]; devuelve una función [0]} _e (e, r) {if (e) {if (typeof console! = = "undefined") console.error (r)} else throw new Error (r)} function Ae (e, r) {var t = e; Xr (t, 0); var a = [], n = [] ; var i = {FileIndex: a, FullPaths: n}; E (i, {root: r.root}); var l = t.length-4; while ((t [l]! = 80 || t [ l + 1]! = 75 || t [l + 2]! = 5 || t [l + 3]! = 6) && l> = 0) - l; tl = l + 4; t.l + = 4 ; var o = t._R (2); t.l + = 6; var f = t._R (4); tl = f; para (l = 0; l <o; ++ l) {t.l + = 20; var c = t._R (4); var h = t._R (4);var u = t._R (2); var d = t._R (2); var p = t._R (2); t.l + = 8; var v = t._R (4); var m = s (t.slice (t.l + u, t.l + u + d)); t.l + = u + d + p; var g = tl; tl = v + 4; Ee (t, c, h, i, m); tl = g} return i} función Ee (e, r, t, a, n) {e.l + = 2; var l = e._R (2); var o = e._R (2 ); var f = i (e); if (l & 8257) arroja un nuevo error ("Cifrado ZIP no compatible"); var c = e._R (4); var h = e._R (4); var u = e. _R (4); var d = e._R (2); var p = e._R (2); var v = ""; for (var m = 0; m <d; ++ m) v + = String. fromCharCode (e [e.l ++]); if (p) {var g = s (e.slice (el, e.l + p)); if ((g [21589] || {}). mt) f = g [21589] .mt; if (((n || {}) [21589] || {}). mt) f = n [21589] .mt} e.l + = p; var b = e.slice (el, e.l + h); interruptor (o) {caso 8: b = Y (e, u); descanso; caso 0: descanso; valor predeterminado: arrojar nuevo error ("Método de compresión ZIP no compatible" + o); } var w = falso; if (l & 8) {c = e._R (4); if (c == 134695760) {c = e._R (4); w = verdadero} h = e._R (4); u = e._R (4)} if (h! = r) _e (w, "Tamaño comprimido incorrecto:" + r + "! =" + h);if (u! = t) _e (w, "Tamaño descomprimido incorrecto:" + t + "! =" + u); var k = U.buf (b, 0); if (c >> 0! = k >> 0) _e (w, "Suma de comprobación CRC32 incorrecta:" + c + "! =" + K); Oe (a, v, b, {inseguro: verdadero, mt: f})} función Te (e, r) {var t = r || {}; var a = [], i = []; var s = Yr (1); var l = t.compression? 8: 0, o = 0; var f = false; if (f ) o | = 8; var c = 0, h = 0; var u = 0, d = 0; var p = e.FullPaths [0], v = p, m = e.FileIndex [0]; var g = []; var b = 0; for (c = 1; c <e.FullPaths.length; ++ c) {v = e.FullPaths [c] .slice (p.length); m = e.FileIndex [c ]; if (! m.size ||! m.content || v == "? Sh33tJ5") continuar; var w = u; var k = Yr (v.length); for (h = 0; h <v .length; ++ h) k._W (1, v.charCodeAt (h) & 127); k = k.slice (0, kl); g [d] = U.buf (m.content, 0); var y = m.contenido; if (l == 8) y = J (y); s = Yr (30); s._W (4,67324752); s._W (2,20); s._W (2 , o); s._W (2, l); if (m.mt) n (s, m.mt); más s._W (4,0); s._W (-4, o & 8? 0: g [d]); s._W (4, o & 8? 0: y.length); s._W (4, o & 8? 0: m.content.longitud); s._W (2, k.length); s._W (2,0); u + = s.length; a.push (s); u + = k.length; a.push (k); u + = y.length; a.push (y); if (o & 8) {s = Yr (12); s._W (-4, g [d]); s._W (4, y.length); s. _W (4, m.content.length); u + = sl; a.push (s)} s = Yr (46); s._W (4,33639248); s._W (2,0); s._W (2,20); s._W (2, o); s._W (2, l); s._W (4,0); s._W (-4, g [d]); s._W ( 4, y.length); s._W (4, m.content.length); s._W (2, k.length); s._W (2,0); s._W (2,0); s ._W (2,0); s._W (2,0); s._W (4,0); s._W (4, w); b + = sl; i.push (s); b + = k. longitud; i.push (k); ++ d} s = Año (22); s._W (4,101010256); s._W (2,0); s._W (2,0); s._W (2, d); s._W (2, d); s._W (4, b); s._W (4, u); s._W (2,0); devuelve O ([O (a) , O (i), s])} función Fe (e) {var r = {}; E (r, e); return r} función Oe (e, r, t, n) {var i = n && n.unsafe ; if (! i) E (e); var s =! i && j.find (e, r); if (! s) {var l = e.FullPaths [0]; if (r.slice (0, l. longitud) == l) l = r; más {if (l.slice (-1)! = "/") l + = "/"; l = (l + r) .replace ("//", "/ ")} s = {nombre: a (r), escriba: 2}; e.FileIndex.push (s); e.FullPaths.push (l); if (! i) j.utils.cfb_gc (e)} s .content = t; s.size = t? t.length: 0; if (n) {if (n.CLSID) s.clsid = n.CLSID; if (n.mt) s.mt = n.mt; if (n.ct) s.ct = n.ct} return s} función De (e, r) {E (e); var t = j.find (e, r); if (t) para (var a = 0; a <e.FileIndex.length; ++ a) if (e.FileIndex [a] == t) {e.FileIndex.splice (a, 1); e.FullPaths.splice (a, 1); return true} return false} function Me (e, r, t) {E (e); var n = j.find (e, r); if (n) para (var i = 0; i <e.FileIndex. length; ++ i) if (e.FileIndex [i] == n) {e.FileIndex [i] .name = a (t); e.FullPaths [i] = t; return true} return false} function Pe (e) {F (e, verdadero)} e.find = R; e.read = A; e.parse = f; e.write = V; e.writeFile = $; e.utils = {cfb_new: Fe, cfb_add: Oe, cfb_del: De, cfb_mov: Me, cfb_gc: Pe, ReadShift: Wr, CheckField: Vr, prep_blob: Xr, bconcat: O, use_zlib: G, _deflateRaw: ue, _inflateRaw: Ce, consts: W}; e} (); if (typeof require! == "undefined" &&typeof module! == "undefined" && typeof W === "undefined") {module.exports = j} var H; if (typeof require! == "undefined") intente {H = require ("fs")} catch (x) {} función V (e) {if (typeof e === "string") devuelve A (e); if (Array.isArray (e)) devuelve T (e); devuelve e} función X (e , r, t) {if (typeof H! == "undefined" && H.writeFileSync) devuelve t? H.writeFileSync (e, r, t): H.writeFileSync (e, r); var a = t == " utf8 "? Ge (r): r; if (typeof IE_SaveFile! ==" undefined ") devuelve IE_SaveFile (a, e); if (typeof Blob! ==" undefined ") {var n = new Blob ([V ( a)], {type: "application / octet-stream"}); if (typeof navigator! == "undefined" && navigator.msSaveBlob) return navigator.msSaveBlob (n, e); if (typeof saveAs! == "undefined ") devuelve saveAs (n, e); if (typeof URL! ==" undefined "&& typeof document!== "undefined" && document.createElement && URL.createObjectURL) {var i = URL.createObjectURL (n); if (typeof chrome === "object" && typeof (chrome.downloads || {}). download == "function") {if (URL.revokeObjectURL && typeof setTimeout! == "undefined") setTimeout (function () {URL.revokeObjectURL (i)}, 6e4); return chrome.downloads.download ({url: i, filename: e, saveAs: true })} var s = document.createElement ("a"); if (s.download! = null) {s.download = e; s.href = i; document.body.appendChild (s); s.click ( ); document.body.removeChild (s); if (URL.revokeObjectURL && typeof setTimeout! == "undefined") setTimeout (function () {URL.revokeObjectURL (i)}, 6e4); return i}}} if (typeof $ ! == "undefined" && typeof File! == "undefined" && typeof Folder! == "undefined") intente {var l = File (e); l.open ("w"); l.encoding = "binary"; if (Array.isArray (r)) r = E (r); l.write (r); l.close (); return r} catch (o ) {if (! o.message ||! o.message.match (/ onstruct /)) throw o} throw new Error ("no se puede guardar el archivo" + e)} función G (e) {if (typeof H! = = "undefined") devuelve H.readFileSync (e); if (typeof $! == "undefined" && typeof File! == "undefined" && typeof Folder! == "undefined") intente {var r = File (e); r.open ("r"); r.encoding = "binary"; var t = r.read (); r.close (); return t} catch (a) {if (! a.message ||! a .message.match (/ onstruct /)) arrojar un} arrojar un nuevo error ("No se puede acceder al archivo" + e)} función Y (e) {var r = Object.keys (e), t = []; para (var a = 0; a <r.length; ++ a) if (e.hasOwnProperty (r [a])) t.push (r [a]); return t} function J (e, r) {var t = [], a = Y (e); for (var n = 0; n! == a.length; ++ n) if (t [e [a [n]] [r]] == null) t [ e [a [n]] [r]] = a [n];return t} función Z (e) {var r = [], t = Y (e); para (var a = 0; a! == t.length; ++ a) r [e [t [a]] ] = t [a]; retorno r} función q (e) {var r = [], t = Y (e); para (var a = 0; a! == t.length; ++ a) r [ e [t [a]]] = parseInt (t [a], 10); devuelve r} función K (e) {var r = [], t = Y (e); for (var a = 0; a! == t.length; ++ a) {if (r [e [t [a]]] == null) r [e [t [a]]] = []; r [e [t [a]] ] .push (t [a])} return r} var Q = nueva Fecha (1899,11,30,0,0,0); var ee = Q.getTime () + ((nueva Fecha) .getTimezoneOffset () -Q.getTimezoneOffset ()) * 6e4; función re (e, r) {var t = e.getTime (); if (r) t- = 1462 * 24 * 60 * 60 * 1e3; return (t-ee) / (24 * 60 * 60 * 1e3)} función te (e) {var r = nueva Fecha; r.setTime (e * 24 * 60 * 60 * 1e3 + ee); devuelve r} función ae (e) {var r = 0, t = 0, a = falso; var n = e.match (/ P ([0-9 \.] + Y)? ([0-9 \.] + M)? ([0-9 \.] + D)? T ([0-9 \.] + H)? ([0-9 \.] + M)? ([0-9 \.] + S)? /); If (! n) lanzar un nuevo error ("|" + e + "| no es una duración ISO8601"); para (var i = 1; i! = n.length; ++ i) {if (! n [i]) continuar; t = 1; si (i> 3) a = verdadero;switch (n [i] .slice (n [i] .length-1)) {case "Y": arroja un nuevo error ("campo de duración ISO no compatible:" + n [i] .slice (n [i] .length -1)); caso "D": t * = 24; caso "H": t * = 60; caso "M": si (! A) arroja un nuevo error ("Campo de duración ISO no compatible: M"); de lo contrario t * = 60; caso "S": break;} r + = t * parseInt (n [i], 10)} return r} var ne = new Date ("2017-02-19T19: 06: 09.000Z"); if (isNaN (ne.getFullYear ())) ne = new Date ("2/19/17"); var ie = ne.getFullYear () == 2017; function se (e, r) {var t = new Date (e); if (es decir) {if (r> 0) t.setTime (t.getTime () + t.getTimezoneOffset () * 60 * 1e3); si if (r <0) t.setTime (t.getTime () -t.getTimezoneOffset () * 60 * 1e3); return t} if (e instanceof Date) return e; if (ne.getFullYear () == 1917 &&! isNaN (t.getFullYear ())) {var a = t.getFullYear (); if (e.indexOf ("" + a)> - 1) devuelve t; t.setFullYear (t.getFullYear () + 100);return t} var n = e.match (/ \ d + / g) || ["2017", "2", "19", "0", "0", "0"]; var i = nueva Fecha ( + n [0], + n [1] -1, + n [2], + n [3] || 0, + n [4] || 0, + n [5] || 0); si ( e.indexOf ("Z")> - 1) i = nueva Fecha (i.getTime () - i.getTimezoneOffset () * 60 * 1e3); devuelve i} function le (e) {var r = ""; para (var t = 0; t! = e.length; ++ t) r + = String.fromCharCode (e [t]); return r} function oe (e) {if (typeof JSON! = "undefined" &&! Array .isArray (e)) devuelve JSON.parse (JSON.stringify (e)); if (typeof e! = "object" || e == null) return e; if (e instanceof Date) return new Date (e. getTime ()); var r = {}; for (var t in e) if (e.hasOwnProperty (t)) r [t] = oe (e [t]); return r} function fe (e, r) {var t = ""; while (t.length <r) t + = e; return t} function ce (e) {var r = Number (e); if (! isNaN (r)) return r; var t = 1; var a = e.replace (/ ([\ d]), ([\ d]) / g, "$ 1 $ 2").reemplazar (/ [$] / g, ""). reemplazar (/ [%] / g, function () {t * = 100; return ""}); if (! isNaN (r = Number (a))) return r / t; a = a.replace (/[(font>(.*)[)font>/, función (e, r) {t = -t; return r}); if (! isNaN (r = Number ( a))) return r / t; return r} function he (e) {var r = new Date (e), t = new Date (NaN); var a = r.getYear (), n = r.getMonth ( ), i = r.getDate (); if (isNaN (i)) devuelve t; if (a <0 || a> 8099) devuelve t; if ((n> 0 || i> 1) && a! = 101 ) return r; if (e.toLowerCase (). match (/ jan | feb | mar | apr | may | jun | jul | aug | sep | oct | nov | dec /)) return r; if (e.match ( / [^ - 0-9:, \ / \\] /)) return t; return r} var ue = "abacaba" .split (/ (:? b) / i) .length == 5; function de ( e, r, t) {if (ue || typeof r == "string") devuelve e.split (r); var a = e.split (r), n = [a [0]]; para (var i = 1; i <a.length; ++ i) {n.push (t); n.push (a [i])} return n} function pe (e) {if (! e) return null; if (e.data) return d (e.data); if (e.asNodeBuffer && w) return d (e.asNodeBuffer (). toString ("binary")); if (e.asBinary) return d (e.asBinary ()); if (e._data && e._data.getContent) return d (le (Array.prototype.slice.call (e._data.getContent (), 0))); if (e.content && e.type) return d (le (e.content)); return null} function ve (e) {if (! e) return null; if (e.data) return c (e.data); if (e.asNodeBuffer && w) return e.asNodeBuffer (); if (e._data && e._data.getContent) {var r = e._data.getContent (); if (typeof r == "string") return c (r); return Array.prototype.slice.call (r)} if (e.content && e.type) return e.content; return null} function me (e) {return e && e.name.slice (-4) === ". bin"? ve (e): pe (e)} function ge (e, r) {var t = e.FullPaths || Y (e.files); var a = r.toLowerCase (), n = a.replace (/ \\ / g, "/"); for (var i = 0; i <t.length; ++ i) {var s = t [i ] .replace (/ ^ Root Entry [\ /] /, ""). toLowerCase ();if (a == s || n == s) return e.FileIndex [i]} return null} function be (e, r) {var t = ge (e, r); if (t == null) throw nuevo error ("No se puede encontrar el archivo" + r + "en zip"); devolver t} función we (e, r, t) {if (! t) return me (be (e, r)); if (! r) return null; try {return we (e, r)} catch (a) {return null}} function ke (e, r, t) {if (! t) return pe (be (e, r)); if ( ! r) return null; intente {return ke (e, r)} catch (a) {return null}} function ye (e) {var r = e.FullPaths || Y (e.files), t = [] ; for (var a = 0; a <r.length; ++ a) if (r [a] .slice (-1)! = "/") t.push (r [a] .replace (/ ^ Root Entrada [\ /] /, "")); devuelve t.sort ()} función xe (e, r, t) {if (e.FullPaths) j.utils.cfb_add (e, r, typeof t == " cadena "? w? k (t): _ (Ge (t)): t); más e.file (r, t)} función Se () {return j.utils.cfb_new ()} función Ce (e, r) {var t; switch (r.type) {case "base64": t = j.read (e, {type: "base64"}); break; case "binary": t = j.read (e, {tipo:"binary"}); break; case "buffer":; case "array": t = j.read (e, {type: "buffer"}); break; default: throw new Error ("Tipo no reconocido" + r .type);} return t} function _e (e, r) {if (e.charAt (0) == "/") return e.slice (1); var t = r.split ("/"); if (r.slice (-1)! = "/") t.pop (); var a = e.split ("/"); while (a.length! == 0) {var n = a.shift (); if (n === "..") t.pop (); sino if (n! == ".") t.push (n)} devuelve t.join ("/")} var Ae = '<? xml version = "1.0" encoding = "UTF-8" standalone = "yes"?> \ r \ n'; var Ee = / ([^ "\ s?> \ /] +) \ s * = \ s * ((?: ") ([^"] *) (?: ") | (?: ') ([^'] *) (?: ') | ([^'"> \ s] +)) / g; var Te = / <[\ / \?]? [a-zA-Z0-9: _-] + (?: \ s + [^ "\ s?> \ /] + \ s * = \ s * (?: "[^"] * "| '[^'] * '| [^'">\ s =] +)) * \ s? [\ / \?]?> / g; if (! Ae.match (Te)) Te = / <[^>] *> / g; var Fe = / < \ w *: /, Oe = / <(\ /?) \ w +: /; function De (e, r, t) {var a = {}; var n = 0, i = 0; for (; n! == e.length; ++ n) if ((i = e.charCodeAt (n)) === 32 || i === 10 || i === 13) break; if (! r) a [ 0] = e.slice (0, n); if (n === e.length) devuelve a; var s = e.match (Ee), l = 0, o = "", f = 0, c = "", h = "", u = 1; if (s) for (f = 0; f! = s.length; ++ f) {h = s [f]; for (i = 0; i! = h.length; ++ i) if (h.charCodeAt (i) === 61) break; c = h.slice (0, i) .trim (); while (h.charCodeAt (i + 1) == 32) ++ i; u = (n = h.charCodeAt (i + 1)) == 34 || n == 39? 1: 0; o = h.slice (i + 1 + u, h.length- u); for (l = 0; l! = c.length; ++ l) if (c.charCodeAt (l) === 58) break; if (l === c.length) {if (c. indexOf ("_")> 0) c = c.slice (0, c.indexOf ("_")); a [c] = o; if (! t) a [c.toLowerCase ()] = o} else {var d = (l === 5 && c.slice (0,5) === "xmlns"? "xmlns": "") + c.slice (l + 1); if (a [d] && c. rebanada (l-3,l) == "ext") continuar; a [d] = o; if (! t) a [d.toLowerCase ()] = o}} return a} function Me (e) {return e.replace (Oe, "<$ 1")} var Pe = {"& quot;": '"'," & apos; ":" '"," & gt; ":"> "," & lt; ":" <"," & amp; " : "&"}; var Re = Z (Pe); var Ne = function () {var e = / & (?: quot | apos | gt | lt | amp | #x? ([\ da-fA-F ] +)); / g, r = / _ x ([\ da-fA-F] {4}) _ / g; función de retorno t (a) {var n = a + "", i = n.indexOf (" <! [CDATA ["); if (i == - 1) return n.replace (e, function (e, r) {return Pe [e] || String.fromCharCode (parseInt (r, e.indexOf (" x ")> - 1? 16: 10)) || e}). replace (r, function (e, r) {return String.fromCharCode (parseInt (r, 16))}); var s = n.indexOf ("]]>"); devuelve t (n.slice (0, i)) + n.slice (i + 9, s) + t (n.slice (s + 3))}} (); var Ie = / [& <> '"] / g,Le = / [\ u0000- \ u0008 \ u000b- \ u001f] / g; función Be (e) {var r = e + ""; return r.replace (Ie, function (e) {return Re [e]}) .replace (Le, función (e) {return "_x" + ("000" + e.charCodeAt (0) .toString (16)). slice (-4) + "_"})} function ze (e) {return Be (e) .replace (/ / g, "_ x0020 _")} var We = / [\ u0000- \ u001f] / g; function $ e (e) {var r = e + ""; return r.replace (Es decir, función (e) {return Re [e]}). Replace (/ \ n / g, "<br/>") .replace (We, function (e) {return "& # x" + (" 000 "+ e.charCodeAt (0) .toString (16)). Slice (-4) +"; "})} function Ue (e) {var r = e +" "; return r.replace (Ie, function ( e) {return Re [e]}). replace (We, function (e) {return "& # x" + e.charCodeAt (0) .toString (16) .toUpperCase () + ";"})} var je = function () {var e = / & # (\ d +); / g; function r (e, r) {return String.fromCharCode (parseInt (r,10))} función de retorno t (a) {return a.replace (e, r)}} (); var He = function () {return function e (r) {return r.replace (/ (\ r \ n | [\ r \ n]) / g, "& # 10;")}} (); función Ve (e) {switch (e) {case 1:; case true:; case "1":; case " verdadero ":; caso" VERDADERO ": devuelve verdadero; predeterminado: devuelve falso;}} var Xe = función Fl (e) {var r =" ", t = 0, a = 0, n = 0, i = 0, s = 0, l = 0; while (t <e.length) {a = e.charCodeAt (t ++); if (a <128) {r + = String.fromCharCode (a); continuar} n = e.charCodeAt ( t ++); if (a> 191 && a <224) {s = (a & 31) << 6; s | = n & 63; r + = String.fromCharCode (s); continuar} i = e.charCodeAt (t ++); if (a < 240) {r + = String.fromCharCode ((a & 15) << 12 | (n & 63) << 6 | i & 63); continuar} s = e.charCodeAt (t ++); l = ((a & 7) << 18 | (n & 63) << 12 | (i & 63) << 6 | s & 63) -65536; r + = String.fromCharCode (55296+ (l >>> 10 & 1023)); r + = String.fromCharCode (56320+ (l & 1023))} return r}; var Ge = function (e) {var r = [], t = 0, a = 0, n = 0; while (t <e.length) {a = e.charCodeAt (t ++); switch (true) {case a <128: r.push (String.fromCharCode (a)); break; case a <2048: r.push (String.fromCharCode (192+ (a >> 6))); r.push (String.fromCharCode (128+ (a & 63))); break; case a> = 55296 && a <57344: a- = 55296; n = e.charCodeAt (t ++) - 56320+ (a < <10); r.push (String.fromCharCode (240+ (n >> 18 y 7))); r.push (String.fromCharCode (144+ (n >> 12 y 63))); r.push (String.fromCharCode ( 128+ (n >> 6 y 63))); r.push (String.fromCharCode (128+ (n & 63))); break; predeterminado: r.push (String.fromCharCode (224+ (a >> 12))); r.push (String.fromCharCode (128+ (a >> 6 y 63))); r.push (String.fromCharCode (128+ (a & 63)));}} return r.join ("")}; if (w ) {var Ye = función Ol (e) {var r = Buffer.alloc (2 * e.length), t, a, n = 1, i = 0, s = 0, l;para (a = 0; a <e.length; a + = n) {n = 1; if ((l = e.charCodeAt (a)) <128) t = l; sino if (l <224) {t = (l & 31) * 64 + (e.charCodeAt (a + 1) & 63); n = 2} más si (l <240) {t = (l & 15) * 4096 + (e.charCodeAt (a + 1) & 63) * 64+ (e.charCodeAt (a + 2) & 63); n = 3} más {n = 4; t = (l & 7) * 262144 + (e.charCodeAt (a + 1) & 63) * 4096 + (e.charCodeAt (a + 2) & 63) * 64 + (e.charCodeAt (a + 3) & 63); t- = 65536; s = 55296 + (t >>> 10 y 1023); t = 56320 + (t & 1023)} if (s ! == 0) {r [i ++] = s & 255; r [i ++] = s >>> 8; s = 0} r [i ++] = t% 256; r [i ++] = t >>> 8} return r .slice (0, i) .toString ("ucs2")}; var Je = "foo bar bazâ ???? ð ???? £"; if (Xe (Je) == Ye (Je)) Xe = Ye; var Ze = función Dl (e) {return k (e, "binary"). ToString ("utf8")}; if (Xe (Je) == Ze (Je)) Xe = Ze; Ge = function ( e) {return k (e, "utf8"). toString ("binary")}} var qe = function () {var e = {}; return function r (t, a) {var n = t + "|"+ (a || ""); if (e [n]) return e [n]; return e [n] = new RegExp ("<(?: \\ w + :)?" + t + '(?: xml : espacio = "preservar")? (?: [^>] *)> ([\\ s \\ S] *?) </ (?: \\ w +:)? '+ t + ">", a | | "")}} (); var Ke = función () {var e = [["nbsp", ""], ["middot", "·"], ["quot", '"'], [ "apos", "'"], ["gt", ">"], ["lt", "<"], ["amp", "&"]]. map (function (e) {return [new RegExp ("&" + e [0] + ";", "g"), e [1]]}); función de retorno r (t) {var a = t.replace (/ ^ [\ t \ n \ r] + /, ""). replace (/ [\ t \ n \ r] + $ /, ""). replace (/> \ s + / g, ">"). replace (/ \ s + </ g , "<"). replace (/ [\ t \ n \ r] + / g, "") .replace (/ <\ s * [bB] [rR] \ s * \ /?> / g, "\ norte").reemplazar (/ <[^>] *> / g, "");
para (var n = 0; n <e.length; ++ n) a = a.replace (e [n] [0], e [n] [1]); devuelve a}} (); var Qe = function () {var e = {}; return function r (t) {if (e [t]! == undefined) return e [t]; return e [t] = new RegExp ("<(?: vt: )? "+ t +"> ([\\ s \\ S] *?) </ (?: vt :)? "+ t +"> "," g ")}} (); var er = / <\ /? (?: vt :)? variante> / g, rr = / <(?: vt:) ([^>] *)> ([\ s \ S] *) </; función tr (e, r ) {var t = De (e); var a = e.match (Qe (t.baseType)) || []; var n = []; if (a.length! = t.size) {if (r .WTF) arrojar un nuevo error ("longitud de vector inesperada" + a.length + "! =" + T.size); return n} a.forEach (function (e) {var r = e.replace (er, "") .match (rr); if (r) n.push ({v: Xe (r [2]), t: r [1]})}); return n} var ar = / (^ \ s | \ s $ | \ n) /; función nr (e, r) {return "<" + e + (r.match (ar)? 'xml: space = "preserve"': "") + ">" + r + "< / "+ e +"> "} function ir (e) {return Y (e) .map (function (r) {return "" + r + '= "' + e [r] + '"'}). join ("")} function sr ( e, r, t) {return "<" + e + (t! = null? ir (t): "") + (r! = null? (r.match (ar)? 'xml: space = "preserve" ': "") + ">" + r + "</" + e: "/") + ">"} function lr (e, r) {try {return e.toISOString (). replace (/ \. \ d * /, "")} catch (t) {if (r) throw t} return ""} function o (e) {switch (typeof e) {case "string": return sr ("vt: lpwstr", Be (e)); case "número": return sr ((e | 0) == e? "Vt: i4": "vt: r8", Be (String (e))); case "boolean": return sr ("vt: bool", e? "true": "false");} if (e instanceof Date) devuelve sr ("vt: filetime", lr (e)); arroja un nuevo error ("No se puede serializar"+ e)} var fr = {dc: "http://purl.org/dc/elements/1.1/", dcterms: "http://purl.org/dc/terms/", dcmitype: "http: / /purl.org/dc/dcmitype/",mx:"http://schemas.microsoft.com/office/mac/excel/2008/main",r:"http://schemas.openxmlformats.org/officeDocument/ 2006 / relations ", sjs:" http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties ", vt:" http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes ", xsi : "http://www.w3.org/2001/XMLSchema-instance", xsd: "http://www.w3.org/2001/XMLSchema"}; fr.main = ["http: // esquemas. openxmlformats.org/spreadsheetml/2006/main","http://purl.oclc.org/ooxml/spreadsheetml/main","http://schemas.microsoft.com/office/excel/2006/main "," http://schemas.microsoft.com/office/excel/2006/2 "];var cr = {o: "urna: esquemas-microsoft-com: oficina: oficina", x: "urna: esquemas-microsoft-com: oficina: excel", ss: "urna: esquemas-microsoft-com: oficina: hoja de cálculo ", dt:" uuid: C2F41010-65B3-11d1-A29F-00AA00C14882 ", mv:" http: // macVmlSchemaUri ", v:" urna: esquemas-microsoft-com: vml ", html:" http: // www .w3.org / TR / REC-html40 "}; función hr (e, r) {var t = 1-2 * (e [r + 7] >>> 7); var a = ((e [r + 7] & 127) << 4) + (e [r + 6] >>> 4 y 15); var n = e [r + 6] & 15; para (var i = 5; i> = 0; - i) n = n * 256 + e [r + i]; if (a == 2047) devuelve n == 0? t * Infinity: NaN; if (a == 0) a = -1022; else {a- = 1023; n + = Math.pow (2,52)} return t * Math.pow (2, a-52) * n} función ur (e, r, t) {var a = (r <0 || 1 / r = = -Infinito? 1: 0) << 7, n = 0, i = 0; var s = a? -R: r; if (! IsFinite (s)) {n = 2047; i = isNaN (r)? 26985: 0} else if (s == 0) n = i = 0; else {n = Math.floor (Math.log (s) /Math.LN2); i = s * Math.pow (2,52- norte);if (n <= - 1023 && (! isFinite (i) || i <Math.pow (2,52))) {n = -1022} else {i- = Math.pow (2,52); n + = 1023 }} para (var l = 0; l <= 5; ++ l, i / = 256) e [t + l] = i & 255; e [t + 6] = (n & 15) << 4 | i & 15; e [ t + 7] = n >> 4 | a} var dr = función (e) {var r = [], t = 10240; para (var a = 0; a <e [0] .length; ++ a) if (e [0] [a]) para (var n = 0, i = e [0] [a] .length; n <i; n + = t) r.push.apply (r, e [0] [ a] .slice (n, n + t)); return r}; var pr = dr; var vr = function (e, r, t) {var a = []; for (var n = r; n <t ; n + = 2) a.push (String.fromCharCode (Nr (e, n))); devuelve a.join (""). replace (D, "")}; var mr = vr; var gr = function ( e, r, t) {var a = []; para (var n = r; n <r + t; ++ n) a.push (("0" + e [n] .toString (16)). slice (-2)); return a.join ("")}; var br = gr; var wr = function (e, r, t) {var a = []; for (var n = r; n <t ; n ++) a.push (String.fromCharCode (Rr (e, n))); return a.join ("")}; var kr = wr; var yr = function (e, r) {var t = Lr ( e, r);return t> 0? wr (e, r + 4, r + 4 + t-1): ""}; var xr = yr; var Sr = función (e, r) {var t = Lr (e, r) ; return t> 0? wr (e, r + 4, r + 4 + t-1): ""}; var Cr = Sr; var _r = función (e, r) {var t = 2 * Lr (e , r); devuelve t> 0? wr (e, r + 4, r + 4 + t-1): ""}; var Ar = _r; var Er, Tr; Er = Tr = función Ml (e, r ) {var t = Lr (e, r); devuelve t> 0? vr (e, r + 4, r + 4 + t): ""}; var Fr = función (e, r) {var t = Lr (e, r); devuelve t> 0? wr (e, r + 4, r + 4 + t): ""}; var Or = Fr; var Dr, Mr; Dr = Mr = función (e, r) {return hr (e, r)}; var Pr = function Pl (e) {return Array.isArray (e)}; if (w) {vr = function (e, r, t) {if (! Buffer.isBuffer (e)) return mr (e, r, t); return e.toString ("utf16le", r, t) .replace (D, "")}; gr = function (e, r, t) {return Buffer .isBuffer (e)? e.toString ("hex", r, r + t): br (e, r, t)}; yr = función Rl (e, r) {if (! Buffer.isBuffer (e) ) devuelve xr (e, r); var t = e.readUInt32LE (r); devuelve t> 0? e.toString ("utf8",r + 4, r + 4 + t-1): ""}; Sr = función Nl (e, r) {if (! Buffer.isBuffer (e)) devuelve Cr (e, r); var t = e. readUInt32LE (r); devuelve t> 0? e.toString ("utf8", r + 4, r + 4 + t-1): ""}; _ r = función Il (e, r) {if (! Buffer. isBuffer (e)) devuelve Ar (e, r); var t = 2 * e.readUInt32LE (r); devuelve e.toString ("utf16le", r + 4, r + 4 + t-1)}; Er = función Ll (e, r) {if (! Buffer.isBuffer (e)) devuelve Tr (e, r); var t = e.readUInt32LE (r); devuelve e.toString ("utf16le", r + 4, r + 4 + t)}; Fr = función Bl (e, r) {if (! Buffer.isBuffer (e)) return Or (e, r); var t = e.readUInt32LE (r); return e.toString ( "utf8", r + 4, r + 4 + t)}; wr = función zl (e, r, t) {return Buffer.isBuffer (e)? e.toString ("utf8", r, t): kr (e, r, t)}; dr = función (e) {return e [0] .length> 0 && Buffer.isBuffer (e [0] [0])? Buffer.concat (e [0]): pr (e )}; O = función (e) {return Buffer.isBuffer (e [0])? Buffer.concat (e): []. Concat.apply ([], e)};Dr = función Wl (e, r) {if (Buffer.isBuffer (e)) return e.readDoubleLE (r); return Mr (e, r)}; Pr = function $ l (e) {return Buffer.isBuffer ( e) || Array.isArray (e)}} if (typeof cptable! == "undefined") {vr = function (e, r, t) {return cptable.utils.decode (1200, e.slice (r, t)). replace (D, "")}; wr = function (e, r, t) {return cptable.utils.decode (65001, e.slice (r, t))}; yr = function (e, r) {var a = Lr (e, r); devuelve a> 0? cptable.utils.decode (t, e.slice (r + 4, r + 4 + a-1)): ""}; Sr = función (e, t) {var a = Lr (e, t); devuelve a> 0? cptable.utils.decode (r, e.slice (t + 4, t + 4 + a-1)): "" }; _ r = función (e, r) {var t = 2 * Lr (e, r); devuelve t> 0? cptable.utils.decode (1200, e.slice (r + 4, r + 4 + t- 1)): ""}; Er = función (e, r) {var t = Lr (e, r); devuelve t> 0? Cptable.utils.decode (1200, e.slice (r + 4, r + 4 + t)): ""}; Fr = función (e, r) {var t = Lr (e, r); devuelve t> 0? Cptable.utils.decode (65001, e.slice (r + 4,r + 4 + t)): ""}} var Rr = función (e, r) {return e [r]}; var Nr = función (e, r) {return e [r + 1] * (1 < <8) + e [r]}; var Ir = función (e, r) {var t = e [r + 1] * (1 << 8) + e [r]; devuelve t <32768? T :( 65535-t + 1) * - 1}; var Lr = función (e, r) {return e [r + 3] * (1 << 24) + (e [r + 2] << 16) + (e [r + 1] << 8) + e [r]}; var Br = función (e, r) {return e [r + 3] << 24 | e [r + 2] << 16 | e [r +1] << 8 | e [r]}; var zr = función (e, r) {return e [r] << 24 | e [r + 1] << 16 | e [r + 2] << 8 | e [r + 3]}; función Wr (e, t) {var a = "", n, i, s = [], l, o, f, c; switch (t) {case "dbcs" : c = this.l; if (w && Buffer.isBuffer (this)) a = this.slice (this.l, this.l + 2 * e) .toString ("utf16le"); más para (f = 0; f <e; ++ f) {a + = String.fromCharCode (Nr (this, c)); c + = 2} e * = 2; break; case "utf8": a = wr (this, this.l, this. l + e); break; case "utf16le": e * = 2; a = vr (this, this.l, this.l + e); break; case "wstr ": if (typeof cptable! ==" undefined ") a = cptable.utils.decode (r, this.slice (this.l, this.l + 2 * e)); de lo contrario, devuelve Wr.call (this, e, "dbcs"); e = 2 * e; break; case "lpstr-ansi": a = yr (this, this.l); e = 4 + Lr (this, this.l); break; case " lpstr-cp ": a = Sr (this, this.l); e = 4 + Lr (this, this.l); break; case" lpwstr ": a = _r (this, this.l); e = 4 + 2 * Lr (this, this.l); break; case "lpp4": e = 4 + Lr (this, this.l); a = Er (this, this.l); if (e & 2) e + = 2 ; break; case "8lpp4": e = 4 + Lr (this, this.l); a = Fr (this, this.l); if (e & 3) e + = 4- (e & 3); break; case "cstr" : e = 0; a = ""; while ((l = Rr (this, this.l + e ++))! == 0) s.push (p (l)); a = s.join ("") ; break; case "_wstr": e = 0; a = ""; while ((l = Nr (this, this.l + e))! == 0) {s.push (p (l)); e + = 2} e + = 2; a = s.join (""); break; case "dbcs-cont": a = ""; c = this.l; for (f = 0; f <e;++ f) {if (this.lens && this.lens.indexOf (c)! == - 1) {l = Rr (this, c); this.l = c + 1; o = Wr.call (this, ef , l? "dbcs-cont": "sbcs-cont"); devuelve s.join ("") + o} s.push (p (Nr (this, c))); c + = 2} a = s. join (""); e * = 2; break; case "cpstr": if (typeof cptable! == "undefined") {a = cptable.utils.decode (r, this.slice (this.l, this. l + e)); break}; case "sbcs-cont": a = ""; c = this.l; for (f = 0; f! = e; ++ f) {if (this.lens && this.lens .indexOf (c)! == - 1) {l = Rr (this, c); this.l = c + 1; o = Wr.call (this, ef, l? "dbcs-cont": "sbcs- cont "); return s.join (" ") + o} s.push (p (Rr (this, c))); c + = 1} a = s.join (" "); break; default: switch ( e) {caso 1: n = Rr (this, this.l); this.l ++; return n; caso 2: n = (t === "i"? Ir: Nr) (this, this.l); this.l + = 2; return n; case 4:; case-4: if (t === "i" || (this [this.l + 3] & 128) === 0) {n = (e>0? Br: zr) (this, this.l); this.l + = 4; return n} else {i = Lr (this, this.l); this.l + = 4} return i; case 8:; case -8: if (t === "f") {if (e == 8) i = Dr (this, this.l); else i = Dr ([this [this.l + 7], this [this .l + 6], esto [this.l + 5], esto [this.l + 4], esto [this.l + 3], esto [this.l + 2], esto [this.l + 1] , this [this.l + 0]], 0); this.l + = 8; return i} else e = 8; case 16: a = gr (this, this.l, e); break;};} this .l + = e; devuelve a} var $ r = función (e, r, t) {e [t] = r & 255; e [t + 1] = r >>> 8 & 255; e [t + 2] = r> >> 16 y 255; e [t + 3] = r >>> 24 y 255}; var Ur = función (e, r, t) {e [t] = r & 255; e [t + 1] = r >> 8 y 255; e [t + 2] = r >> 16 y 255; e [t + 3] = r >> 24 y 255}; var jr = función (e, r, t) {e [t] = r & 255; e [t + 1] = r >>> 8 & 255}; función Hr (e, r, a) {var n = 0, i = 0; if (a === "dbcs") {for (i = 0; i! = r.length; ++ i) jr (this, r.charCodeAt (i), this.l + 2 * i); n = 2 * r.length} else if (a === "sbcs") {if (typeof cptable! == "undefined" && t == 874) {for (i = 0; i! = r.length; ++ i) {var s = cptable.utils.encode (t, r.charAt (i)); this [this.l + i] = s [0]}} else {r = r.replace (/ [^ \ x00- \ x7F] / g, "_"); for (i = 0 ; i! = r.length; ++ i) this [this.l + i] = r.charCodeAt (i) & 255} n = r.length} else if (a === "hex") {for (; i <e; ++ i) {this [this.l ++] = parseInt (r.slice (2 * i, 2 * i + 2), 16) || 0} devolver esto} más si (a === " utf16le ") {var l = Math.min (this.l + e, this.length); para (i = 0; i <Math.min (r.length, e); ++ i) {var o = r .charCodeAt (i); this [this.l ++] = o & 255; this [this.l ++] = o >> 8} while (this.l <l) this [this.l ++] = 0; return this} else switch ( e) {caso 1: n = 1; this [this.l] = r & 255; break; caso 2: n = 2; this [this.l] = r & 255; r >>> = 8; this [this.l + 1] = r & 255; break; caso 3: n = 3; this [this.l] = r & 255; r >>> = 8; this [this.l + 1] = r & 255; r >>> = 8; this [ this.l + 2] = r & 255;break; caso 4: n = 4; $ r (this, r, this.l); break; caso 8: n = 8; if (a === "f") {ur (this, r, this.l ); break}; caso 16: break; case-4: n = 4; Ur (this, r, this.l); break;} this.l + = n; devuelve esta} función Vr (e, r) {var t = gr (this, this.l, e.length >> 1); if (t! == e) arroja un nuevo error (r + "Esperado" + e + "saw" + t); this.l + = e.length >> 1} función Xr (e, r) {el = r; e._R = Wr; e.chk = Vr; e._W = Hr} función Gr (e, r) {e.l + = r} función Yr (e) {var r = S (e); Xr (r, 0); return r} función Jr (e, r, t) {if (! e) return; var a, n, i; Xr (e, el || 0); var s = e.length, l = 0, o = 0; while (el <s) {l = e._R (1); if (l & 128) l = (l & 127) + ((e ._R (1) & 127) << 7); var f = XLSBRecordEnum [l] || XLSBRecordEnum [65535]; a = e._R (1); i = a & 127; for (n = 1; n <4 && a & 128; + + n) i + = ((a = e._R (1)) & 127) << 7 * n; o = e.l + i; var c = (ff || Gr) (e, i, t); el = o; if (r (c, fn, l)) return}} function Zr () {var e = [], r = w? 256: 2048;var t = función o (e) {var r = Yr (e); Xr (r, 0); return r}; var a = t (r); var n = función f () {if (! a) return ; if (a.length> al) {a = a.slice (0, al); al = a.length} if (a.length> 0) e.push (a); a = null}; var i = función c (e) {if (a && e <a.length-al) devuelve a; n (); devuelve a = t (Math.max (e + 1, r))}; var s = función h () {n (); return dr ([e])}; var l = función u (e) {n (); a = e; if (al == null) al = a.length; i (r)}; return { siguiente: i, push: l, end: s, _bufs: e}} function qr (e, r, t, a) {var n = + XLSBRE [r], i; if (isNaN (n)) return; if (! a) a = XLSBRecordEnum [n] .p || (t || []). length || 0; i = 1 + (n> = 128? 1: 0) +1; if (a> = 128 ) ++ i; if (a> = 16384) ++ i; if (a> = 2097152) ++ i; var s = e.next (i); if (n <= 127) s._W (1, n); else {s._W (1, (n & 127) +128); s._W (1, n >> 7)} para (var l = 0; l! = 4; ++ l) {if (a > = 128) {s._W (1, (a & 127) +128); a >> = 7} más {s._W (1, a); break}} if (a> 0 && Pr (t)) e.push (t)} función Kr (e, r, t) {var a = oe (e); if (rs) {if (a.cRel) a.c + = rsc; if (a.rRel) a.r + = rsr} else {if (a.cRel) a.c + = rc; if (a.rRel) a.r + = rr} if (! t || t. biff <12) {while (ac> = 256) ac- = 256; while (ar> = 65536) ar- = 65536} devuelve una} función Qr (e, r, t) {var a = oe (e); as = Kr (as, rs, t); ae = Kr (ae, rs, t); devuelve una} función et (e, r) {if (e.cRel && e.c <0) {e = oe (e) ; while (ec <0) e.c + = r> 8? 16384: 256} if (e.rRel && e.r <0) {e = oe (e); while (er <0) e.r + = r> 8 ? 1048576: r> 5? 65536: 16384} var t = ut (e); if (! E.cRel && e.cRel! = Null) t = ot (t); if (! E.rRel && e.rRel! = Null) t = nt (t); devuelve t} función rt (e, r) {if (esr == 0 &&! esrRel) {if (eer == (r.biff> = 12? 1048575: r.biff> = 8? 65536: 16384) &&! EerRel) {return (escRel? "": "$") + Lt (esc) + ":" + (eecRel? "": "$") + Lt (eec)}} if (esc == 0 &&! EscRel) {if (eec == (r.biff> = 12? 65535: 255) &&! EecRel) {return (esrRel? "": "$") + at (esr) + ":" + (eerRel? "": "$") + at (eer)}} return et (es, r.biff) + ":" + et (ee, r.biff)} función tt (e) {return parseInt (it (e), 10) -1} función en (e) {return "" + (e + 1)} función nt (e) {return e.replace (/ ([AZ] | ^) (\ d +) $ /, "$ 1 $$$ 2")} funciona (e) {return e.replace (/ \ $ (\ d + ) $ /, "$ 1")} función st (e) {var r = ft (e), t = 0, a = 0; para (; a! == r.length; ++ a) t = 26 * t + r.charCodeAt (a) -64; devuelve t-1} función lt (e) {if (e <0) arroja un nuevo error ("columna no válida" + e); var r = ""; para (++ e; e; e = Math.floor ((e-1) / 26)) r = String.fromCharCode ((e-1)% 26 + 65) + r; return r} función ot (e) {return e. reemplazar (/ ^ ([AZ]) /, "$$$ 1")} función ft (e) {return e.replace (/ ^ \ $ ([AZ]) /, "$ 1")} function ct (e) {return e.replace (/ (\ $? [AZ] *) (\ $? \ d *) /, "$ 1, $ 2"). split (",")} función ht (e) {var r = ct (e); return {c: st (r [0]), r: tt (r [1])}} función ut (e) {return lt (ec ) + en (er)} función dt (e) {var r = e.split (":"). map (ht); return {s: r [0], e: r [r.length-1]} } función pt (e, r) {if (typeof r === "undefined" || typeof r === "number") {return pt (es, ee)} if (typeof e! == "string") e = ut (e); if (typeof r! == "string") r = ut (r); return e == r? e: e + ":" + r} function vt (e) {var r = { s: {c: 0, r: 0}, e: {c: 0, r: 0}}; var t = 0, a = 0, n = 0; var i = e.length; for (t = 0 ; a <i; ++ a) {if ((n = e.charCodeAt (a) -64) <1 || n> 26) break; t = 26 * t + n} rsc = - t; for ( t = 0; a <i; ++ a) {if ((n = e.charCodeAt (a) -48) <0 || n> 9) break; t = 10 * t + n} rsr = - t ; if (a === i || e.charCodeAt (++ a) === 58) {rec = rsc; rer = rsr; devuelve r} para (t = 0; a! = i; ++ a) {if ((n = e.charCodeAt (a) -64) <1 || n> 26) break; t = 26 * t + n} rec = - t; for (t = 0; a! = i; ++ a) {if ((n = e.charCodeAt (a) -48) <0 || n>9) break; t = 10 * t + n} rer = - t; return r} function mt (e, r) {var t = et == "d" && r instanceof Date; if (ez! = Null) intente {return ew = P.format (ez, t? re (r): r)} catch (a) {} try {return ew = P.format ((e.XF || {}). numFmtId || (t ? 14: 0), t? Re (r): r)} catch (a) {return "" + r}} función gt (e, r, t) {if (e == null || et == null || et == "z") return ""; if (ew! == undefined) return ew; if (et == "d" &&! ez && t && t.dateNF) ez = t.dateNF; if (r == undefined ) return mt (e, ev); return mt (e, r)} función bt (e, r) {var t = r && r.sheet? r.sheet: "Sheet1"; var a = {}; a [t] = e; return {SheetNames: [t], Sheets: a}} function wt (e, r, t) {var a = t || {}; var n = e? Array.isArray (e): a.dense ; if (m! = null && n == null) n = m; var i = e || (n? []: {}); var s = 0, l = 0; if (i && a.origin! = null) { if (typeof a.origin == "number") s = a.origin; else {var o = typeof a.origin == "cadena "? ht (a.origin): a.origin; s = or; l = oc}} var f = {s: {c: 1e7, r: 1e7}, e: {c: 0, r: 0} }; if (i ["! ref"]) {var c = vt (i ["! ref"]); fsc = csc; fsr = csr; fec = Math.max (fec, cec); fer = Math. max (fer, cer); if (s == - 1) fer = s = cer + 1} for (var h = 0; h! = r.length; ++ h) {if (! r [h]) continuar; si (! Array.isArray (r [h])) arroja un nuevo error ("aoa_to_sheet espera una matriz de matrices"); for (var u = 0; u! = r [h] .length; ++ u) {if (typeof r [h] [u] === "undefined") continuar; var d = {v: r [h] [u]}; var p = s + h, v = l + u; if ( fsr> p) fsr = p; if (fsc> v) fsc = v; if (fer <p) fer = p; if (fec <v) fec = v; if (r [h] [u] && typeof r [ h] [u] === "objeto" &&! Array.isArray (r [h] [u]) &&! (r [h] [u] instancia de fecha)) d = r [h] [u]; de lo contrario {if (Array.isArray (dv)) {df = r [h] [u] [1]; dv = dv [0]} if (dv === null) {if (df) dt = "n"; más si (! a.sheetStubs) continúa; de lo contrario d.t = "z"} más if (typeof dv === "number") dt = "n"; else if (typeof dv === "boolean") dt = "b"; else if (dv instanceof Date) { dz = a.dateNF || P._table [14]; if (a.cellDates) {dt = "d"; dw = P.format (dz, re (dv))} else {dt = "n"; dv = re (dv); dw = P.format (dz, dv)}} else dt = "s"} if (n) {if (! i [p]) i [p] = []; if (i [ p] [v] && i [p] [v] .z) dz = i [p] [v] .z; i [p] [v] = d} else {var g = ut ({c: v, r : p}); if (i [g] && i [g] .z) dz = i [g] .z; i [g] = d}}} if (fsc <1e7) i ["! ref"] = pt (f); return i} function kt (e, r) {return wt (null, e, r)} var yt = 2; var xt = 3; var St = 11; var Ct = 12; var _t = 19 ; var At = 30; var Et = 64; var Tt = 65; var Ft = 71; var Ot = 4096; var Dt = 80; var Mt = 81; var Pt = [Dt, Mt]; var Rt = {1 : {n: "CodePage", t: yt}, 2: {n: "Categoría", t: Dt}, 3: {n: "PresentationFormat", t: Dt}, 4: {n: "ByteCount", t: xt}, 5: {n: "LineCount ", t: xt}, 6: {n:" ParagraphCount ", t: xt}, 7: {n:" SlideCount ", t: xt}, 8: {n:" NoteCount ", t: xt}, 9: {n: "HiddenCount", t: xt}, 10: {n: "MultimediaClipCount", t: xt}, 11: {n: "ScaleCrop", t: St}, 12: {n: "HeadingPairs" , t: Ot | Ct}, 13: {n: "TitlesOfParts", t: Ot | At}, 14: {n: "Gerente", t: Dt}, 15: {n: "Compañía", t: Dt }, 16: {n: "LinksUpToDate", t: St}, 17: {n: "CharacterCount", t: xt}, 19: {n: "SharedDoc", t: St}, 22: {n: " HyperlinksChanged ", t: St}, 23: {n:" AppVersion ", t: xt, p:" version "}, 24: {n:" DigSig ", t: Tt}, 26: {n:" ContentType " , t: Dt}, 27: {n: "ContentStatus", t: Dt}, 28: {n: "Idioma", t: Dt}, 29: {n: "Versión", t: Dt}, 255: {}}; var Nt = {1: {n: "CodePage", t: yt}, 2: {n: "Título", t: Dt}, 3: {n: "Asunto ", t: Dt}, 4: {n:" Autor ", t: Dt}, 5: {n:" Palabras clave ", t: Dt}, 6: {n:" Comentarios ", t: Dt}, 7: {n: "Plantilla", t: Dt}, 8: {n: "Último Autor", t: Dt}, 9: {n: "RevNumber", t: Dt}, 10: {n: "EditTime" , t: Et}, 11: {n: "Última impresión", t: Et}, 12: {n: "CreatedDate", t: Et}, 13: {n: "ModifiedDate", t: Et}, 14: {n: "PageCount", t: xt}, 15: {n: "WordCount", t: xt}, 16: {n: "CharCount", t: xt}, 17: {n: "Miniatura", t : Ft}, 18: {n: "Aplicación", t: Dt}, 19: {n: "DocSecurity", t: xt}, 255: {}}; var It = {2147483648: {n: "Locale" , t: _t}, 2147483651: {n: "Comportamiento", t: _t}, 1919054434: {}}; (function () {for (var e in It) if (It.hasOwnProperty (e)) Rt [e ] = Nt [e] = It [e]}) (); var Lt = J (Rt, "n"); var Bt = J (Nt, "n"); var zt = {1: "US", 2: "CA", 3: "",7: "RU", 20: "EG", 30: "GR", 31: "NL", 32: "BE", 33: "FR", 34: "ES", 36: "HU", 39: "IT", 41: "CH", 43: "AT", 44: "GB", 45: "DK", 46: "SE", 47: "NO", 48: "PL", 49: "DE ", 52:" MX ", 55:" BR ", 61:" AU ", 64:" NZ ", 66:" TH ", 81:" JP ", 82:" KR ", 84:" VN ", 86: "CN", 90: "TR", 105: "JS", 213: "DZ", 216: "MA", 218: "LY", 351: "PT", 354: "IS", 358: "FI", 420: "CZ", 886: "TW", 961: "LB", 962: "JO", 963: "SY", 964: "IQ", 965: "KW", 966: "SA ", 971:" AE ", 972:" IL ", 974:" QA ", 981:" IR ", 65535:"US "}; var Wt = [nulo," sólido "," mediumGray "," darkGray "," lightGray "," darkHorizontal "," darkVertical "," darkDown "," darkUp "," darkGrid "," darkTrellis ", "lightHorizontal", "lightVertical", "lightDown", "lightUp", "lightGrid", "lightTrellis", "gray125", "gray0625"]; función $ t (e) {return e.map (function (e) { retorno [e >> 16 y 255, e >> 8 y 255, e y 255]})} var Ut = $ t ([0,16777215,16711680,65280,255,16776960,16711935,65535,0,16777215,16711680,65280,255, 16776960,16711935,65535,8388608,32768,128,8421376,8388736,32896,12632256,8421504,10066431,10040166,16777164,13434879,6684774,16744576,26316,13421823,128,16711935,16776960,65535887676960,6558,887 32896,255,52479,13434879,13434828,16777113,10079487,16751052,13408767,16764057,3368703,3394764,10079232,16763904,16750848,16737792,6710937,9868950,13158,3381606,13056,3355392,10040064,10040166,3355545,335544,0,077235 0,0,0,0,0,0,0,0,0,0,0,0,0]); var jt = oe (Ut); var Ht = {"application / vnd.openxmlformats-officedocument.spreadsheetml .sheet.main + xml ":" libros de trabajo "," application / vnd.ms-excel.binIndexWs ":" TODO "," application / vnd.ms-excel.intlmacrosheet ":" TODO "," application / vnd.ms -excel.binIndexMs ":" TODO "," application / vnd.openxmlformats-package.core-properties + xml ":" coreprops "," application / vnd.openxmlformats-officedocument.custom-properties + xml ":" custprops ", "application / vnd.openxmlformats-officedocument.extended-properties + xml": "extprops", "application / vnd.openxmlformats-officedocument.customXmlProperties + xml ":" TODO "," application / vnd.openxmlformats-officedocument.spreadsheetml.customProperty ":" TODO "," application / vnd.ms-excel.pivotTable ":" TODO " , "application / vnd.openxmlformats-officedocument.spreadsheetml.pivotTable + xml": "TODO", "application / vnd.openxmlformats-officedocument.drawingml.chart + xml": "TODO", "application / vnd.ms-office. chartcolorstyle + xml ":" TODO "," application / vnd.ms-office.chartstyle + xml ":" TODO "," application / vnd.ms-office.chartex + xml ":" TODO "," application / vnd. ms-excel.calcChain ":" calcchains "," application / vnd.openxmlformats-officedocument.spreadsheetml.calcChain + xml ":" calcchains ","application / vnd.openxmlformats-officedocument.spreadsheetml.printerSettings ":" TODO "," application / vnd.ms-office.activeX ":" TODO "," application / vnd.ms-office.activeX + xml ":" TODO " , "application / vnd.ms-excel.attachedToolbars": "TODO", "application / vnd.ms-excel.connections": "TODO", "application / vnd.openxmlformats-officedocument.spreadsheetml.connections + xml": " TODO "," application / vnd.ms-excel.externalLink ":" links "," application / vnd.openxmlformats-officedocument.spreadsheetml.externalLink + xml ":" links "," application / vnd.ms-excel.sheetMetadata " : "TODO", "application / vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata + xml": "TODO", "application / vnd.ms-excel.pivotCacheDefinition ":" TODO "," application / vnd.ms-excel.pivotCacheRecords ":" TODO "," application / vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition + xml ":" TODO "," application / vnd.openxmlformats- officedocument.spreadsheetml.pivotCacheRecords + xml ":" TODO "," application / vnd.ms-excel.queryTable ":" TODO "," application / vnd.openxmlformats-officedocument.spreadsheetml.queryTable + xml ":" TODO "," application / vnd.ms-excel.userNames ":" TODO "," application / vnd.ms-excel.revisionHeaders ":" TODO "," application / vnd.ms-excel.revisionLog ":" TODO "," application / vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders + xml ":" TODO "," application / vnd.openxmlformats-officedocument.spreadsheetml.revisionLog + xml ":" TODO "," application / vnd.openxmlformats-officedocument.spreadsheetml.userNames + xml ":" TODO "," application / vnd.ms-excel.tableSingleCells ":" TODO " , "application / vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells + xml": "TODO", "application / vnd.ms-excel.slicer": "TODO", "application / vnd.ms-excel.slicerCache": " TODO "," application / vnd.ms-excel.slicer + xml ":" TODO "," application / vnd.ms-excel.slicerCache + xml ":" TODO "," application / vnd.ms-excel.wsSortMap " : "TODO", "application / vnd.ms-excel.table": "TODO", "application / vnd.openxmlformats-officedocument.spreadsheetml.table + xml": "TODO", "application / vnd.openxmlformats-officedocument.theme + xml ":" themes "," application / vnd.openxmlformats-officedocument.themeOverride + xml ":" TODO "," application / vnd.ms-excel.Timeline + xml ":" TODO "," application / vnd.ms-excel.TimelineCache + xml ":" TODO "," application / vnd.ms-office.vbaProject ":" vba "," application / vnd.ms-office.vbaProjectSignature ":" vba "," application / vnd.ms-office.volatileDependencies ":" TODO "," application / vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies + xml ":" TODO "," application / vnd.ms-excel.controlproperties + xml ":" TODO "," application / vnd.openxmlformats-officedocument.model + data ":" TODO "," application / vnd.ms-excel.Survey + xml ":"TODO "," application / vnd.openxmlformats-officedocument.drawing + xml ":" dibujos "," application / vnd.openxmlformats-officedocument.drawingml.chartshapes + xml ":" TODO "," application / vnd.openxmlformats-officedocument. drawingml.diagramColors + xml ":" TODO "," application / vnd.openxmlformats-officedocument.drawingml.diagramData + xml ":" TODO "," application / vnd.openxmlformats-officedocument.drawingml.diagramLayout + xml ":" TODO " , "application / vnd.openxmlformats-officedocument.drawingml.diagramStyle + xml": "TODO", "application / vnd.openxmlformats-officedocument.vmlDrawing": "TODO", "application / vnd.openxmlformats-package.relationships + xml" : "rels", "application / vnd.openxmlformats-officedocument.oleObject": "TODO "," image / png ":" TODO ", hoja:" js "}; var Vt = función () {var e = {libros de trabajo: {xlsx:" application / vnd.openxmlformats-officedocument.spreadsheetml.sheet.main + xml ", xlsm:" application / vnd.ms-excel.sheet.macroEnabled.main + xml ", xlsb:" application / vnd.ms-excel.sheet.binary.macroEnabled.main ", xlam:" application / vnd .ms-excel.addin.macroEnabled.main + xml ", xltx:" application / vnd.openxmlformats-officedocument.spreadsheetml.template.main + xml "}, strs: {xlsx:" application / vnd.openxmlformats-officedocument.spreadsheetml .sharedStrings + xml ", xlsb:" application / vnd.ms-excel.sharedStrings "}, comentarios: {xlsx:" application / vnd.openxmlformats-officedocument.spreadsheetml.comments + xml ", xlsb:" application / vnd.ms -excel.comments "}, hojas: {xlsx:" application / vnd.openxmlformats-officedocument.spreadsheetml.worksheet + xml ", xlsb:" application / vnd.ms-excel.worksheet "}, gráficos: {xlsx:" application / vnd.openxmlformats-officedocument.spreadsheetml.chartsheet + xml ", xlsb:" application / vnd.ms-excel.chartsheet "}, cuadros de diálogo: {xlsx:" application / vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet + xml ", xlsb:" application / vnd.ms-excel.dialogsheet "}, macros: {xlsx: "application / vnd.ms-excel.macrosheet + xml", xlsb: "application / vnd.ms-excel.macrosheet"}, estilos: {xlsx: "application / vnd.openxmlformats-officedocument.spreadsheetml.styles + xml ", xlsb:" application / vnd.ms-excel.styles "}}; Y (e) .forEach (function (r) {[" xlsm "," xlam "]. forEach (function (t) {if ( ! e [r] [t]) e [r] [t] = e [r] .xlsx})}); Y (e) .forEach (función (r) {Y (e [r]).forEach (function (t) {Ht [e [r] [t]] = r})}); return e} (); var Xt = K (Ht); fr.CT = "http: //schemas.openxmlformats .org / package / 2006 / content-types "; función Gt () {return {libros de trabajo: [], hojas: [], gráficos: [], diálogos: [], macros: [], rels: [], strs : [], comentarios: [], enlaces: [], coreprops: [], extprops: [], custprops: [], themes: [], styles: [], calcchains: [], vba: [], dibujos : [], TODO: [], xmlns: ""}} función Yt (e) {var r = Gt (); if (! E ||! E.match) devuelve r; var t = {}; (e .match (Te) || []). forEach (function (e) {var a = De (e); switch (a [0] .replace (Fe, "<")) {case "<? xml": break; case "<Tipos": r.xmlns = a ["xmlns" + (a [0] .match (/ <(\ w +): /) || ["", ""]) [1]]; break; case "<Default": t [a.Extension] = a.ContentType; break; case "<Override": if (r [Ht [a.ContentType]]! == undefined) r [Ht [a.ContentType ]]. push (a.PartName); break;}}); if (r.xmlns! == fr.CT) arroja un nuevo error ("Espacio de nombres desconocido:" + r.xmlns); r.calcchain = r.calcchains.length> 0? r.calcchains [0]: ""; r.sst = r .strs.length> 0? r.strs [0]: ""; r.style = r.styles.length> 0? r.styles [0]: ""; r.defaults = t; eliminar r.calcchains; return r} var Jt = sr ("Tipos", nulo, {xmlns: fr.CT, "xmlns: xsd": fr.xsd, "xmlns: xsi": fr.xsi}); var Zt = [["xml "," application / xml "], [" bin "," application / vnd.ms-excel.sheet.binary.macroEnabled.main "], [" vml "," application / vnd.openxmlformats-officedocument.vmlDrawing "] , ["data", "application / vnd.openxmlformats-officedocument.model + data"], ["bmp", "image / bmp"], ["png", "image / png"], ["gif", "image / gif"], ["emf", "image / x-emf "], [" wmf "," image / x-wmf "], [" jpg "," image / jpeg "], [" jpeg "," image / jpeg "], [" tif " , "image / tiff"], ["tiff", "image / tiff"], ["pdf", "application / pdf"], ["rels", Xt.rels [0]]]. map (function ( e) {return sr ("Predeterminado", nulo, {Extensión: e [0], ContentType: e [1]})}); función qt (e, r) {var t = [], a; t [t .length] = Ae; t [t.length] = Jt; t = t.concat (Zt); var n = function (n) {if (e [n] && e [n] .length> 0) {a = e [n] [0]; t [t.length] = sr ("Override", null, {PartName: (a [0] == "/"? "": "/") + a, ContentType: Vt [n] [r.bookType || "xlsx"]})}}; var i = function (a) {(e [a] || []). forEach (function (e) {t [t.length] = sr ("Override", nulo, {PartName: (e [0] == "/"? "": "/") + e, ContentType: Vt [a] [r.bookType || "xlsx"]})})}; var s = function (r) {(e [r] || []). forEach (function (e) {t [t.length] = sr ("Override ", nulo, {PartName: (e [0] ==" / "?" ":" / ") + e, ContentType: Xt [r] [0]})})}; n (" libros de trabajo "); i ("hojas"); i ("gráficos"); s ("temas"); ["strs", "estilos"]. forEach (n); ["coreprops", "extprops", "custprops"]. forEach (s); s ("vba"); s ("comentarios"); s ("dibujos"); if (t.length> 2) {t [t.length] = "</Types>"; t [1] = t [1] .replace ("/>", ">")} return t.join ("")} var Kt = {WB: "http://schemas.openxmlformats.org/officeDocument/2006 /relationships/officeDocument",SHEET:"http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",HLINK:"http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",VML:"http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",XPATH:"http://schemas.openxmlformats. org / officeDocument / 2006 / relations / externalLinkPath ", XMISS:" http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing ", XLINK:" http://schemas.openxmlformats.org/officeDocument/ 2006 / relations / externalLink ", VBA:" http://schemas.microsoft.com/office/2006/relationships/vbaProject "}; función Qt (e) {var r = e.lastIndexOf (" / "); return e .slice (0, r + 1) + "_ rels /" + e.slice (r + 1) + ". rels"} función ea (e, r) {var t = {"! id": {}}; if (! e) return t; if (r.charAt (0)! == "/") {r = "/" + r} var a = {}; (e.match (Te) || []) .forEach (function (e) {var n = De (e);if (n [0] === "<Relación") {var i = {}; i.Type = n.Type; i.Target = n.Target; i.Id = n.Id; i.TargetMode = n .TargetMode; var s = n.TargetMode === "External"? N.Target: _e (n.Target, r); t [s] = i; a [n.Id] = i}}); t [ "! id"] = a; return t} fr.RELS = "http://schemas.openxmlformats.org/package/2006/relationships"; var ra = sr ("Relaciones", nulo, {xmlns: fr.RELS }); función ta (e) {var r = [Ae, ra]; Y (e ["! id"]). forEach (function (t) {r [r.length] = sr ("Relación", nulo , e ["! id"] [t])}); if (r.length> 2) {r [r.length] = "</Relationships>"; r [1] = r [1] .replace ( "/>", ">")} return r.join ("")} var aa = [Kt.HLINK, Kt.XPATH, Kt.XMISS]; función na (e, r, t, a, n, i ) {if (! n) n = {}; if (! e ["! id"]) e ["! id"] = {}; if (r <0) para (r = 1; e ["! id "] [" rId "+ r]; ++ r) {} n.Id =" rId "+ r; n.Type = a; n.Target = t; if (i) n.TargetMode = i; else if (aa.indexOf (n.Type)> - 1) n.TargetMode = "Externo"; if ( e ["! id"] [n.Id]) arroja un nuevo error ("No se puede reescribir rId" + r); e ["! id"] [n.Id] = n; e [("/" + n. Objetivo) .replace ("//", "/")] = n; return r} var ia = [["cp: category", "Category"], ["cp: contentStatus", "ContentStatus"], [ "cp: palabras clave", "Palabras clave"], ["cp: lastModifiedBy", "LastAuthor"], ["cp: lastPrinted", "LastPrinted"], ["cp: revision", "RevNumber"], ["cp : versión "," Versión "], [" dc: creador "," Autor "], [" dc: descripción "," Comentarios "], [" dc: identificador "," Identificador "], [" dc: idioma "," Idioma "], [" dc:subject "," Subject "], [" dc: title "," Title "], [" dcterms: created "," CreatedDate "," date "], [" dcterms: modified "," ModifiedDate "," date " ]]; fr.CORE_PROPS = "http://schemas.openxmlformats.org/package/2006/metadata/core-properties"; Kt.CORE_PROPS = "http://schemas.openxmlformats.org/package/2006/relationships/ metadata / core-properties "; var sa = function () {var e = new Array (ia.length); for (var r = 0; r <ia.length; ++ r) {var t = ia [r] ; var a = "(?:" + t [0] .slice (0, t [0] .indexOf (":")) + ":)" + t [0] .slice (t [0] .indexOf (":") + 1); e [r] = nuevo RegExp ("<" + a + "[^>] *> ([\\ s \\ S] *?) </" + A + ">") } return e} (); función la (e) {var r = {}; e = Xe (e); for (var t = 0; t <ia.length; ++ t) {var a = ia [t ], n = e.match (sa [t]); if (n! = null && n.length> 0) r [a [1]] = Ne (n [1]); if (a [2] === "fecha" && r [a [1]]) r [a [1]] = se (r [a [1]])} return r} var oa = sr ("cp: coreProperties", null, {"xmlns: cp": fr.CORE_PROPS, "xmlns: dc": fr.dc, "xmlns : dcterms ": fr.dcterms," ​​xmlns: dcmitype ": fr.dcmitype," xmlns: xsi ": fr.xsi}); función fa (e, r, t, a, n) {if (n [e] ! = null || r == null || r === "") return; n [e] = r; r = Be (r); a [a.length] = t? sr (e, r, t ): nr (e, r)} función ca (e, r) {var t = r || {}; var a = [Ae, oa], n = {}; if (! e &&! t.Props) return a.join (""); if (e) {if (e.CreatedDate! = null) fa ("dcterms: created", typeof e.CreatedDate === "string"? e.CreatedDate: lr (e.CreatedDate , t.WTF), {"xsi: type": "dcterms: W3CDTF"}, a, n); if (e.ModifiedDate! = null) fa ("dcterms: modified", typeof e.ModifiedDate === " string "? e.ModifiedDate: lr (e.ModifiedDate, t.WTF), {"xsi: type": "dcterms: W3CDTF"}, a, n)} para (var i = 0; i! = Ia.length; ++ i) {var s = ia [ i]; var l = t.Props && t.Props [s [1]]! = null? t.Props [s [1]]: e? e [s [1]]: null; if (l === true ) l = "1"; si if (l === falso) l = "0"; si if (typeof l == "número") l = Cadena (l); if (l! = nulo) fa (s [0], l, null, a, n)} if (a.length> 2) {a [a.length] = "</ cp: coreProperties>"; a [1] = a [1] .replace ( "/>", ">")} return a.join ("")} var ha = [["Aplicación", "Aplicación", "cadena"], ["AppVersion", "AppVersion", "cadena"] , ["Empresa", "Empresa", "cadena"], ["DocSecurity", "DocSecurity", "cadena"], ["Administrador", "Administrador", "cadena"], ["HyperlinksChanged", "HyperlinksChanged "," bool "], [" SharedDoc "," SharedDoc "," bool "], [" LinksUpToDate "," LinksUpToDate "," bool "], [" ScaleCrop "," ScaleCrop "," bool "], ["HeadingPairs", "HeadingPairs", "raw"], ["TitlesOfParts", "TitlesOfParts", "raw"]]; fr.EXT_PROPS = "http://schemas.openxmlformats.org/officeDocument/2006/extended- propiedades "; Kt.EXT_PROPS =" http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties "; var ua = [" Hojas de trabajo "," SheetNames "," NamedRanges "," DefinedNames "," Chartsheets "," ChartNames "]; función da (e, r, t, a) {var n = []; if (typeof e ==" string ") n = tr (e, a); else for (var i = 0; i <longitud e; ++ i) n = n.concat (e [i] .map (function (e) {return {v: e}})); var s = typeof r == "string"? tr (r, a) .map (function (e) {return ev}): r; var l = 0, o = 0; if (s.length> 0) for (var f = 0; f! == n.length; f + = 2) {o = + n [f + 1] .v; switch (n [f] .v) {case "Worksheets":; case "工作 表":; case "Листы":; case "أوراق العمل" :; case "ワ ー ク シ ー ト":; case " גליונות עבודה ":; case" Arbeitsblätter ":; case" Çalışma Sayfaları ":; case" Feuilles de calcul ":; case" Fogli di lavoro ":; case" Folhas de cálculo ":; case" Planilhas ":; case" Regneark ":; case" Hojas de cálculo ":; case" Werkbladen ": t.Worksheets = o; t.SheetNames = s.slice (l, l + o); break; case" Named Ranges ":; case" Rangos con nombre ":; caso" 名 前 付 き 一 覧 ":; caso" Benannte Bereiche ":; caso" Navngivne områder ": t.NamedRanges = o; t.DefinedNames = s.slice (l, l + o); break; case "Charts":; case "Diagramme": t.Chartsheets = o; t.ChartNames = s.slice (l, l + o); break;} l + = o}} function pa (e, r, t) {var a = {}; if (! r) r = {}; e = Xe (e); ha.forEach (function ( t) {var n = (e.match (qe (t [0])) || []) [1]; switch (t [2]) {case "string": r [t [1]] = Ne (n || ""); break; case "bool": r [t [1]] = n === "true"; break; case "raw": var i = e.match (new RegExp ("< "+ t [0] +" [^>] *> ([\\ s \\ S] *?) </ "+ t [0] +"> ")); if (i && i.length> 0) a [t [1]] = i [1]; break;}}); if (a.HeadingPairs && a.TitlesOfParts) da (a.HeadingPairs, a.TitlesOfParts, r, t); return r} var va = sr (" Propiedades ", nulo, {xmlns: fr.EXT_PROPS," xmlns: vt ": fr.vt}); función ma (e) {var r = [], t = sr; if (! E) e = {}; e.Application = "SheetJS"; r [r.length] = Ae; r [r.length] = va; ha.forEach (función (a) {
if (e [a [1]] === undefined) return; var n; switch (a [2]) {case "string": n = Be (String (e [a [1]])); break; case "bool": n = e [a [1]]? "true": "false"; break;} if (n! == undefined) r [r.length] = t (a [0], n) }); r [r.length] = t ("HeadingPairs", t ("vt: vector", t ("vt: variante", "<vt: lpstr> Hojas de trabajo </ vt: lpstr>") + t ( "vt: variant", t ("vt: i4", String (e.Worksheets))), {size: 2, baseType: "variant"})); r [r.length] = t ("TitlesOfParts", t ("vt: vector", e.SheetNames.map (function (e) {return "<vt: lpstr>" + Be (e) + "</ vt: lpstr>"}). join (""), {tamaño: e.Worksheets, baseType: "lpstr"})); if (r.length> 2) {r [r.length] = "</Properties>"; r [1] = r [1] .replace ("/>", ">")} return r.join ("")} fr.CUST_PROPS = "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties"; Kt.CUST_PROPS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties"; var ga = / <[^>] +> [^ <] * / g; función ba (e, r) {var t = {}, a = ""; var n = e.match (ga); if (n) para (var i = 0; i! = n.length; ++ i) {var s = n [i], l = De (s); switch (l [0]) {case "<? xml": break ; case "<Properties": break; case "<property": a = Ne (l.name); break; case "</property>": a = null; break; default: if (s.indexOf ("< vt: ") === 0) {var o = s.split ("> "); var f = o [0] .slice (4), c = o [1]; switch (f) {case" lpstr ":; case" bstr ":; case" lpwstr ": t [a] = Ne (c); break; case" bool ": t [a] = Ve (c); break; case" i1 ":; case "i2":; caso "i4":; caso "i8":; caso "int ":; case" uint ": t [a] = parseInt (c, 10); break; case" r4 ":; case" r8 ":; case" decimal ": t [a] = parseFloat (c); break; case "filetime":; case "date": t [a] = se (c); break; case "cy":; case "error": t [a] = Ne (c); break; default: if (f.slice (-1) == "/") break; if (r.WTF && typeof console! == "undefined") console.warn ("Inesperado", s, f, o);}} más if ( s.slice (0,2) === "</") {} más si (r.WTF) arroja nuevos Error (es);}} return t} var wa = sr ("Propiedades", nulo, {xmlns : fr.CUST_PROPS, "xmlns: vt": fr.vt}); función ka (e) {var r = [Ae, wa]; if (! e) devuelve r.join (""); var t = 1 ; Y (e) .forEach (función a (n) {++ t; r [r.length] = sr ("propiedad", o (e [n]), {fmtid: "{D5CDD505-2E9C-101B- 9397-08002B2CF9AE} ", pid: t, nombre: Be (n)})}); if (r.length> 2) {r [r.length] =" </Properties>";r[1font>=r[1font>.replace("/>",">")}return r.join ("")} function ya (e) {var r = {}, t = e.match (Te), a = 0; var n = false; if (t) for (; a! = t.length; ++ a) {var s = De (t [a]); switch (s [ 0] .replace (/ \ w *: / g, "")) {case "<condense": break; case "<extend": break; case "<shadow": if (! S.val) break; case "<shadow>":; case "<shadow />": r.shadow = 1; break; case "</shadow>": break; case "<charset": if (s.val == "1") break; r.cp = i [parseInt (s.val, 10)]; break; case "<outline": if (! s.val) break; case "<outline>":; case "<outline />" : r.outline = 1; break; case "</outline>": break; case "<rFont": r.name = s.val; break; case "<sz": r.sz = s.val; break ; caso "<strike": if (! s.val) break;case "<strike>":; case "<strike />": r.strike = 1; break; case "</strike>": break; case "<u": if (! s.val) break; switch (s.val) {case "double": r.uval = "double"; break; case "singleAccounting": r.uval = "single-contabilidad"; break; case "doubleAccounting": r.uval = "double- contabilidad "; break;}; case" <u> ":; case" <u /> ": ru = 1; break; case" </u> ": break; case" <b ": if (s.val == "0") break; case "<b>":; case "<b />": rb = 1; break; case "</b>": break; case "<i": if (s. val == "0") break; case "<i>":; case "<i />": ri = 1; break; case "</i>": break; case "<color": if (s .rgb) r.color = s.rgb.slice (2,8); break; case "<familia ": r.family = s.val; break; case" <vertAlign ": r.valign = s.val; break; case" <esquema ": break; case" <extLst ":; case" <extLst> ":; case" </extLst> ": break; case" <ext ": n = true; break; case" </ext> ": n = false; break; default: if (s [0] .charCodeAt ( 1)! == 47 &&! N) arroja un nuevo error ("Formato enriquecido no reconocido" + s [0]);}} return r} var xa = function () {var e = qe ("t"), r = qe ("rPr"); función t (t) {var a = t.match (e); if (! a) return {t: "s", v: ""}; var n = {t: "s" , v: Ne (a [1])}; var i = t.match (r); if (i) ns = ya (i [1]); return n} var a = / <(?: \ w +: )? r> / g, n = / <\ / (?: \ w + :)? r> /; función de retorno i (e) {return e.replace (a, ""). split (n) .map ( t) .filter (función (e) {return ev})}} (); var Sa = función Ul () {var e = / (\ r \ n | \ n) / g; función r (e, r,t) {var a = []; if (eu) a.push ("text-decoration: underline;"); if (e.uval) a.push ("text-underline-style:" + e.uval + " ; "); if (e.sz) a.push (" font-size: "+ e.sz +" pt; "); if (e.outline) a.push (" text-effect: outline; "); if (e.shadow) a.push ("text-shadow: auto;"); r.push ('<span style = "' + a.join (" ") + '">'); if (eb) {r.push ("<b>"); t.push ("</b>")} if (ei) {r.push ("<i>"); t.push ("</i>" )} if (e.strike) {r.push ("<s>"); t.push ("</s>")} var n = e.valign || ""; if (n == "superíndice "|| n ==" super ") n =" sup "; de lo contrario, if (n ==" subíndice ") n =" sub "; if (n! =" ") {r.push (" <"+ n + ">"); t.push ("</" + n + ">")} t.push ("</span>"); devuelve e} función t (t) {var a = [[], tv, []]; if (! tv) return ""; if (ts) r (ts, a [0], a [2]); devuelve un [0] .join ("") + a [1] .replace (e, "<br/>") + a [2] .join ( "")} función de retorno a (e) {return e.map (t) .join ("")}} (); var Ca = / <(?: \ w + :)? t [^>] *> ( [^ <] *) <\ / (?: \ w + :)? t> / g, _a = / <(?: \ w + :)? r> /; var Aa = / <(?: \ w + :) ? rPh. *?> ([\ s \ S] *?) <\ / (?: \ w + :)? rPh> / g; función Ea (e, r) {var t = r? r.cellHTML: true ; var a = {}; if (! e) return null; if (e.match (/ ^ \ s * <(?: \ w + :)? t [^>] *> /)) {at = Ne ( Xe (e.slice (e.indexOf (">") + 1) .split (/ <\ / (?: \ W + :)? T> /) [0] || "")); ar = Xe ( e); if (t) ah = $ e (at)} else if (e.match (_a)) {ar ​​= Xe (e); at = Ne (Xe ((e.replace (Aa, ""). match (Ca) || []). join (""). replace (Te, ""))); if (t) ah = Sa (xa (ar))} return a} var Ta = / <(? : \ w +:)? sst ([^>] *)> ([\ s \ S] *) <\ / (?: \ w + :)? sst> /; var Fa = / <(?: \ w +:)? (? : si | sstItem)> / g; var Oa = / <\ / (?: \ w +:)? (?: si | sstItem)> /; función Da (e, r) {var t = [], a = ""; if (! e) return t; var n = e.match (Ta); if (n) {a = n [2] .replace (Fa, ""). split (Oa); for (var i = 0; i! = A.length; ++ i) {var s = Ea (a [i] .trim (), r); if (s! = Null) t [t.length] = s} n = De (n [1]); t.Count = n.count; t.Unique = n.uniqueCount} return t} Kt.SST = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" ; var Ma = / ^ \ s | \ s $ | [\ t \ n \ r] /; función Pa (e, r) {if (! r.bookSST) return ""; var t = [Ae]; t [t.length] = sr ("sst", null, {xmlns: fr.main [0], count: e.Count, uniqueCount: e.Unique}); for (var a = 0; a! = e. length; ++ a) {if (e [a] == null) continue; var n = e [a]; var i = "<si>"; if (nr) i + = nr; else {i + = "< t "; if (! nt) nt =" "; if (ntmatch (Ma)) i + = 'xml: space = "preserve" '; i + = ">" + Be (nt) + "</t>"} i + = "</si>"; t [t.length] = i} if (t.length > 2) {t [t.length] = "</sst>"; t [1] = t [1] .replace ("/>", ">")} return t.join ("")} function Ra (e) {var r = e.slice (e [0] === "#"? 1: 0) .slice (0,6); return [parseInt (r.slice (0,2), 16) , parseInt (r.slice (2,4), 16), parseInt (r.slice (4,6), 16)]} función Na (e) {for (var r = 0, t = 1; r! = 3; ++ r) t = t * 256 + (e [r]> 255? 255: e [r] <0? 0: e [r]); devuelve t.toString (16) .toUpperCase (). Slice (1)} función Ia (e) {var r = e [0] / 255, t = e [1] / 255, a = e [2] / 255; var n = Math.max (r, t, a ), i = Math.min (r, t, a), s = ni; if (s === 0) devuelve [0,0, r]; var l = 0, o = 0, f = n + i ; o = s / (f> 1? 2-f: f); interruptor (n) {caso r: l = ((ta) / s + 6)% 6; descanso; caso t: l = (ar) / s + 2; break; caso a: l = (rt) / s + 4; break;} return [l / 6, o, f / 2]} función La (e) {var r = e [0], t = e [1], a = e [2];var n = t * 2 * (a <.5? a: 1-a), i = an / 2; var s = [i, i, i], l = 6 * r; var o; if (t! == 0) interruptor (l | 0) {caso 0:; caso 6: o = n * l; s [0] + = n; s [1] + = o; pausa; caso 1: o = n * ( 2-l); s [0] + = o; s [1] + = n; descanso; caso 2: o = n * (l-2); s [1] + = n; s [2] + = o; descanso; caso 3: o = n * (4-l); s [1] + = o; s [2] + = n; descanso; caso 4: o = n * (l-4); s [ 2] + = n; s [0] + = o; descanso; caso 5: o = n * (6-l); s [2] + = o; s [0] + = n; descanso;} para ( var f = 0; f! = 3; ++ f) s [f] = Math.round (s [f] * 255); devuelve s} función Ba (e, r) {if (r === 0) retorno e; var t = Ia (Ra (e)); if (r <0) t [2] = t [2] * (1 + r); si no t [2] = 1- (1-t [2 ]) * (1-r); devuelve Na (La (t))} var za = 6, Wa = 15, $ a = 1, Ua = za; función ja (e) {return Math.floor ((e + Math.round (128 / Ua) / 256) * Ua)} función Ha (e) {return Math.floor ((e-5) /Ua*100+.5) / 100} función Va (e) {return Math .round ((e * Ua + 5) / Ua * 256) / 256} función Xa (e) {return Va (Ha (ja (e)))} función Ga (e) {var r = Math.abs (e -Xa (e)), t = Ua; if (r> .005) para (Ua = $ a; Ua <Wa; ++ Ua) if (Math.abs (e-Xa (e)) <= r) {r = Math.abs (e-Xa (e));t = Ua} Ua = t} función Ya (e) {if (e.width) {e.wpx = ja (e.width); e.wch = Ha (e.wpx); e.MDW = Ua} más if (e.wpx) {e.wch = Ha (e.wpx); e.width = Va (e.wch); e.MDW = Ua} más if (typeof e.wch == "número") {e .width = Va (e.wch); e.wpx = ja (e.width); e.MDW = Ua} if (e.customWidth) delete e.customWidth} var Ja = 96, Za = Ja; function qa ( e) {return e * 96 / Za} función Ka (e) {return e * Za / 96} var Qa = {None: "none", Solid: "solid", Gray50: "mediumGray", Gray75: "darkGray" , Gray25: "lightGray", HorzStripe: "darkHorizontal", VertStripe: "darkVertical", ReverseDiagStripe: "darkDown", DiagStripe: "darkUp", DiagCross: "darkGrid", ThickDiagCross: "darkTrellis", ThinHorzStripeStripe: "lightTrellis" : "lightVertical", ThinReverseDiagStripe: "lightDown", ThinHorzCross: "lightGrid"};function en (e, r, t, a) {r.Borders = []; var n = {}; var i = false; (e [0] .match (Te) || []). forEach (function (function ( e) {var t = De (e); switch (Me (t [0])) {case "<fronteras":; case "<borders>":; case "</borders>": break; case "< border ":; case" <border> ":; case" <border /> ": n = {}; if (t.diagonalUp) n.diagonalUp = Ve (t.diagonalUp); if (t.diagonalDown) n. diagonalDown = Ve (t.diagonalDown); r.Borders.push (n); break; case "</border>": break; case "<left />": break; case "<left":; case "< left> ": break; case" </left> ": break; case" <right /> ": break; case" <right ":; case" <right> ": break; case" </right> ": break; case "<top />": break; case "<top":; case "<top>": break; case "</top> ": break; case" <bottom /> ": break; case" <bottom ":; case" <bottom> ": break; case" </bottom> ": break; case" <diagonal ": ; case "<diagonal>":; case "<diagonal />": break; case "</diagonal>": break; case "<horizontal":; case "<horizontal>":; case "<horizontal /> ": break; case" </horizontal> ": break; case" <vertical ":; case" <vertical> ":; case" <vertical /> ": break; case" </vertical> ": break; case "<start":; case "<start>":; case "<start />": break; case "</start>": break; case "<end":; case "<end>":; case "<end />": break; case "</end>":break; case "<color":; case "<color>": break; case "<color />" :; case "</color>": break; case "<extLst":; case "<extLst>" :; case "</extLst>": break; case "<ext": i = true; break; case "</ext>": i = false; break; default: if (a && a.WTF) {if (! i) arrojar un nuevo error ("no reconocido" + t [0] + "en los bordes")};}})} función rn (e, r, t, a) {r.Fills = []; var n = {} ; var i = false; (e [0] .match (Te) || []). forEach (function (e) {var t = De (e); switch (Me (t [0]))) {case " <fills ":; case" <fills> ":; case" </fills> ": break; case" <fill> ":; case" <fill ":; case" <fill /> ": n = {} ; r.Fills.push (n); break; case "</fill>": break; case "<gradientFill>": break; case "<gradientFill ":; case" </gradientFill> ": r.Fills.push (n); n = {}; break; case" <patternFill ":; case" <patternFill> ": if (t.patternType) n. patternType = t.patternType; break; case "<patternFill />" :; case "</patternFill>": break; case "<bgColor": if (! n.bgColor) n.bgColor = {}; if (t .indexed) n.bgColor.indexed = parseInt (t.indexed, 10); if (t.theme) n.bgColor.theme = parseInt (t.theme, 10); if (t.tint) n.bgColor.tint = parseFloat (t.tint); if (t.rgb) n.bgColor.rgb = t.rgb.slice (-6); break; case "<bgColor />" :; case "</bgColor>": break ; caso "<fgColor": if (! n.fgColor) n.fgColor = {}; if (t.theme) n.fgColor.theme = parseInt (t.theme, 10); if (t.tint) n. fgColor.tint = parseFloat (t.tint); if (t.rgb! = null) n.fgColor.rgb = t.rgb.slice (-6); break; case "<fgColor />" :; case "</ fgColor> ": break; case" <stop ":; case" <stop /> ": break; case" </stop> ": break; case" <color ":; case" <color /> ": break ; case "</color>": break; case "<extLst":; case "<extLst>":; case "</extLst>": break; case "<ext": i = true; break; case " </ext> ": i = false; break; default: if (a && a.WTF) {if (! i) arroja un nuevo error (" no reconocido "+ t [0] +" en rellenos ")};}})} función tn (e, r, t, a) {r.Fonts = []; var n = {}; var s = false; (e [0] .match (Te) || []). forEach (function (function ( e) {var l = De (e); switch (Me (l [0])) {case "<fonts":; case "<fonts>":; case "</fonts>": break; case "< font ":; case" <font> ": break; case" </font> ":; case" <font /> ": r.Fonts.push (n); n = {}; break; case "<name": if (l.val) n.name = l.val; break; case "<name />" :; case "</name>" : break; case "<b": n.bold = l.val? Ve (l.val): 1; break; case "<b />": n.bold = 1; break; case "<i": n.italic = l.val? Ve (l.val): 1; break; case "<i />": n.italic = 1; break; case "<u": switch (l.val) {case " none ": n.underline = 0; break; case" single ": n.underline = 1; break; case" double ": n.underline = 2; break; case" singleAccounting ": n.underline = 33; break; case "doubleAccounting": n.underline = 34; break;} break; case "<u />": n.underline = 1; break; case "<strike": n.strike = l.val? Ve (l. val): 1; break; case "<strike />": n.strike = 1; break; case "<outline": n.outline = l.val? Ve (l.val): 1; break; case " <esquema />": n.outline = 1; break; case" <shadow ": n.shadow = l.val? Ve (l.val): 1; break; case" <shadow /> ": n.shadow = 1; break ; case "<condense": n.condense = l.val? Ve (l.val): 1; break; case "<condense />": n.condense = 1; break; case "<extend": n. extend = l.val? Ve (l.val): 1; break; case "<extend />": n.extend = 1; break; case "<sz": if (l.val) n.sz = + l.val; break; case "<sz />" :; case "</sz>": break; case "<vertAlign": if (l.val) n.vertAlign = l.val; break; case "< vertAlign /> ":; case" </vertAlign> ": break; case" <family ": if (l.val) n.family = parseInt (l.val, 10); break; case" <family /> " :; case "</family>": break; case "<esquema": if (l.val) n.scheme = l.val; break; caso "<esquema />" :; caso "</scheme>":break;case"<charset":if(l.val=="1")break;l.codepage=i[parseInt(l.val,10)font>;break;case"<color ": if (! n.color) n.color = {}; if (l.auto) n.color.auto = Ve (l.auto); if (l.rgb) n.color.rgb = l.rgb.slice (-6); si if (l.indexed) {n.color.index = parseInt (l.indexed, 10); var o = jt [n.color.index]; if (n.color.index == 81 ) o = jt [1]; si (! o) arroja un nuevo error (e); n.color.rgb = o [0] .toString (16) + o [1] .toString (16) + o [2] .toString (16)} más if (l.theme) {n.color.theme = parseInt (l.theme, 10); if (l.tint) n.color.tint = parseFloat (l.tint); if ( l.theme && t.themeElements && t.themeElements.clrScheme) {n.color.rgb = Ba (t.themeElements.clrScheme [n.color.theme] .rgb, n.color.tint || 0)}} break; case "< color /> ":; case" </color> ": break; case" <AlternateContent ": s = true; break; case" </AlternateContent> ": s = false;break; case "<extLst":; case "<extLst>":; case "</extLst>": break; case "<ext": s = true; break; case "</ext>": s = false ; break; default: if (a && a.WTF) {if (! s) arroja un nuevo error ("no reconocido" + l [0] + "en fuentes")};}})} funciona an (e, r, t) {r.NumberFmt = []; var a = Y (P._table); for (var n = 0; n <a.length; ++ n) r.NumberFmt [a [n]] = P._table [a [n]]; var i = e [0] .match (Te); if (! i) return; for (n = 0; n <i.length; ++ n) {var s = De (i [n ]); switch (Me (s [0])) {case "<numFmts":; case "</numFmts>":; case "<numFmts />" :; case "<numFmts>": break; case " <numFmt ": {var l = Ne (Xe (s.formatCode)), o = parseInt (s.numFmtId, 10); r.NumberFmt [o] = l; if (o> 0) {if (o> 392 ) {for (o = 392; o> 60; - o) if (r.NumberFmt [o] == null) break; r.NumberFmt [o] = l} P.load (l, o)}} break ;caso"</numFmt> ": break; default: if (t.WTF) arroja un nuevo error (" no reconocido "+ s [0] +" en numFmts ");}}} función nn (e) {var r = [" < numFmts> "]; [[5,8], [23,26], [41,44], [50,392]]. forEach (function (t) {for (var a = t [0]; a <= t [1]; ++ a) if (e [a]! = Null) r [r.length] = sr ("numFmt", null, {numFmtId: a, formatCode: Be (e [a])})} ); if (r.length === 1) return ""; r [r.length] = "</numFmts>"; r [0] = sr ("numFmts", nulo, {count: r.length- 2}). Replace ("/>", ">"); return r.join ("")} var sn = ["numFmtId", "fillId", "fontId", "borderId", "xfId"]; var ln = ["applyAlignment", "applyBorder", "applyFill", "applyFont", "applyNumberFormat", "applyProtection", "pivotButton", "quotePrefix"];función en (e, r, t) {r.CellXf = []; var a; var n = false; (e [0] .match (Te) || []). forEach (function (e) {var i = De (e), s = 0; switch (Me (i [0])) {case "<cellXfs":; case "<cellXfs>":; case "<cellXfs />" :; case "</ cellXfs > ": break; case" <xf ":; case" <xf /> ": a = i; eliminar a [0]; for (s = 0; s <sn.length; ++ s) if (a [ sn [s]]) a [sn [s]] = parseInt (a [sn [s]], 10); for (s = 0; s <ln.length; ++ s) if (a [ln [s ]]) a [ln [s]] = Ve (a [ln [s]]); if (a.numFmtId> 392) {for (s = 392; s> 60; - s) if (r.NumberFmt [a.numFmtId] == r.NumberFmt [s]) {a.numFmtId = s; break}} r.CellXf.push (a); break; case "</xf>": break; case "<alineación" :; case "<alineación />": var l = {}; if (i.vertical) l.vertical = i.vertical; if (i.horizontal) l.horizontal = i.horizontal; if (i.textRotation! = nulo) l.textRotation = i.textRotation; if (i.indent) l.indent = i.indent;if (i.wrapText) l.wrapText = Ve (i.wrapText); a.alignment = l; break; case "</alignment>": break; case "<protección": break; case "</protection>" :; case "<protection />": break; case "<AlternateContent": n = true; break; case "</AlternateContent>": n = false; break; case "<extLst":; case "<extLst> ":; case" </extLst> ": break; case" <ext ": n = true; break; case" </ext> ": n = false; break; default: if (t && t.WTF) {if ( ! n) lanzar un nuevo error ("no reconocido" + i [0] + "en cellXfs")};}})} función fn (e) {var r = []; r [r.length] = sr ("cellXfs ", null); e.forEach (function (e) {r [r.length] = sr (" xf ", null, e)}); r [r.length] =" </cellXfs> "; if ( r.length === 2) return ""; r [0] = sr ("cellXfs", null, {count: r.length-2}). replace ("/>", ">"); return r.join ("")} var cn = function jl () {var e = / <(?: \ w + :)? numFmts ( [^>] *)> [\ S \ s] *? <\ / (?: \ W + :)? NumFmts> /; var r = / <(?: \ W + :)? CellXfs ([^>] * )> [\ S \ s] *? <\ / (?: \ W + :)? CellXfs> /; var t = / <(?: \ W + :)? Llena ([^>] *)> [\ S \ s] *? <\ / (?: \ w + :)? fills> /; var a = / <(?: \ w + :)? fonts ([^>] *)> [\ S \ s] *? <\ / (?: \ w + :)? fonts> /; var n = / <(?: \ w + :)? fronteras ([^>] *)> [\ S \ s] *? <\ / (? : \ w + :)? fronteras> /; función de retorno i (s, l, o) {var f = {}; if (! s) return f; s = s.replace (/ <! - ([\ s \ S] *?) -> / gm, ""). Reemplazar (/ <! DOCTYPE [^ \ [] * \ [[^ \]] * \]> / gm, ""); var c; if (c = s.match (e)) an (c, f, o); if (c = s.match (a)) tn (c, f, l, o); if (c = s.match (t )) rn (c, f, l, o); if (c = s.match (n)) en (c, f, l, o); if (c = s.match (r)) en (c, f, o); return f}} (); var hn = sr ("styleSheet", null, {xmlns: fr.main [0], "xmlns: vt ": fr.vt}); Kt.STY =" http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles "; función un (e, r) {var t = [Ae, hn ], a; if (e.SSF && (a = nn (e.SSF))! = null) t [t.length] = a; t [t.length] = '<fonts count = "1"> <font > <sz val = "12" /> <color theme = "1" /> <name val = "Calibri" /> <family val = "2" /> <scheme val = "minor" /> </font> </fonts> '; t [t.length] =' <fills count = "2"> <fill> <patternFill patternType = "none" /> </fill> <fill> <patternFill patternType = "gray125" /> </fill> </fills> '; t [t.length] =' <border count = "1"> <border> <left /> <right /> <top /> <bottom /> <diagonal /> < / border> </borders>'; t [t.length] =' <cellStyleXfs count = "1"> <xf numFmtId = "0" fontId = "0" fillId = "0" borderId = "0" /> </cellStyleXfs> '; if ( a = fn (r.cellXfs)) t [t.length] = a; t [t.length] = '<cellStyles count = "1"> <cellStyle name = "Normal" xfId = "0" builtinId = "0 "/> </cellStyles> '; t [t.length] =' <dxfs count =" 0 "/> '; t [t.length] =' <tableStyles count =" 0 "defaultTableStyle =" TableStyleMedium9 "defaultPivotStyle = "PivotStyleMedium4" /> '; if (t.length> 2) {t [t.length] = "</styleSheet>"; t [1] = t [1] .replace ("/>", ">" )} return t.join ("")} Kt.THEME = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme"; función dn (e, r,t) {r.themeElements.clrScheme = []; var a = {}; (e [0] .match (Te) || []). forEach (function (e) {var n = De (e); switch (n [0]) {case "<a: clrScheme":; case "</ a: clrScheme>": break; case "<a: srgbClr": a.rgb = n.val; break; case "<a : sysClr ": a.rgb = n.lastClr; break; case" <a: dk1> ":; case" </ a: dk1> ":; case" <a: lt1> ":; case" </ a : lt1> ":; case" <a: dk2> ":; case" </ a: dk2> ":; case" <a: lt2> ":; case" </ a: lt2> ":; case" <a: acento1> ":; caso" </ a: acento1> ":; caso" <a: acento2> ":; caso" </ a: acento2> ":; caso" <a: acento3> ":; case "</ a: accent3>" :; case "<a: accent4>" :; case "</ a: accent4>" :; case "<a: accent5>" :;case "</ a: accent5>" :; case "<a: accent6>" :; case "</ a: accent6>" :; case "<a: hlink>" :; case "</ a: hlink> ":; case" <a: folHlink> ":; case" </ a: folHlink> ": if (n [0] .charAt (1) ===" / ") {r.themeElements.clrScheme.push ( a); a = {}} else {a.name = n [0] .slice (3, n [0] .length-1)} break; default: if (t && t.WTF) arroja un nuevo error ("No reconocido" + n [0] + "en clrScheme");}})} función pn () {} función vn () {} var mn = / <a: clrScheme ([^>] *)> [\ s \ S] * <\ / a: clrScheme> /; var gn = / <a: fontScheme ([^>] *)> [\ s \ S] * <\ / a: fontScheme> /; var bn = / <a: fmtScheme ([^>] *)> [\ s \ S] * <\ / a: fmtScheme> /; function wn (e, r, t) {r.themeElements = {}; var a; [["clrScheme", mn, dn], ["fontScheme", gn, pn], ["fmtScheme", bn, vn]].forEach (function (n) {if (! (a = e.match (n [1])))) arroja un nuevo error (n [0] + "no encontrado en themeElements"); n [2] (a, r, t)})} var kn = / <a: themeElements ([^>] *)> [\ s \ S] * <\ / a: themeElements> /; función yn (e, r) {if (! e | | e.length === 0) return yn (xn ()); var t; var a = {}; if (! (t = e.match (kn))) arroja un nuevo error ("themeElements no encontrado en el tema "); wn (t [0], a, r); a.raw = e; devuelve una} función xn (e, r) {if (r && r.themeXLSX) devuelve r.themeXLSX; if (e && typeof e.raw = = "cadena") devuelve e.raw; var t = [Ae]; t [t.length] = '<a: theme xmlns: a = "http://schemas.openxmlformats.org/drawingml/2006/main" name = "Office Theme"> '; t [t.length] = "<a: themeElements>"; t [t.length] =' <a: clrScheme name = "Office"> '; t [t.length] = '<a: dk1> <a: sysClr val = "windowText" lastClr = "000000"/></a:dk1>';t[t.lengthfont>='<a:lt1><a:sysClr val = "window" lastClr = "FFFFFF" /> </ a: lt1> '; t [t .length] = '<a: dk2> <a: srgbClr val = "1F497D" /> </ a: dk2>'; t [t.length] = '<a: lt2> <a: srgbClr val = "EEECE1 "/></a:lt2>';t[t.lengthfont>='<a:accent1><a:srgbClr val =" 4F81BD "/> </ a: acento1> '; t [t.length] = '<a: acento2> <a: srgbClr val = "C0504D" /> </ a: acento2>'; t [t.length] = '<a: acento3> <a: srgbClr val = "9BBB59" /> < /a:accent3>';t[t.lengthfont>='<a:accent4><a:srgbClr val = "8064A2" /> </ a: accent4> '; t [t.length] =' <a: acento5> <a: srgbClr val = "4BACC6" /> </ a: acento5> '; t [t.length] =' <a: acento6> <a:srgbClr val = "F79646" /> </ a: acento6> '; t [t.length] =' <a: hlink> <a: srgbClr val = "0000FF" /> </ a: hlink> '; t [ t.length] = '<a: folHlink> <a: srgbClr val = "800080" /> </ a: folHlink>'; t [t.length] = "</ a: clrScheme>"; t [t. longitud] = '<a: fontScheme name = "Office">'; t [t.length] = "<a: majorFont>"; t [t.length] = '<a: latin typeface = "Cambria" /> '; t [t.length] =' <a: ea typeface = "" /> '; t [t.length] =' <a: cs typeface = "" /> '; t [t.length] =' <a: font script = "Jpan" typeface = "ＭＳ Ｐ ゴ シ ッ ク" />';t[t.lengthfont>='<a:font script = "Hang" typeface = "맑은 고딕" /> '; t [t .length] = '<a: font script = "Hans" typeface = "宋体" />'; t [t.length] =' <a: font script = "Hant" typeface = "新 細 明 體" />';t[t.lengthfont>='<a:font script = "Arab" typeface = "Times New Roman" /> '; t [t.length] =' <a: font script = "Hebr" typeface = "Times New Roman" /> '; t [t.length] =' <a: script de fuente = "Tipo de letra tailandés" = "Tahoma" /> '; t [longitud de t] =' <a: fuente script = "Ethi" tipo de letra = "Nyala" /> '; t [longitud de t] =' <a: font script = "Beng" typeface = "Vrinda" /> '; t [t.length] =' <a: font script = "Gujr" typeface = "Shruti" /> '; t [t.length] =' < a: font script = "Khmr" typeface = "MoolBoran" /> '; t [t.length] =' <a: font script = "Knda" typeface = "Tunga" /> '; t [t.length] = '<a:font script = "Guru" typeface = "Raavi" /> '; t [t.length] =' <a: font script = "Cans" typeface = "Euphemia" /> '; t [t.length] =' < a: font script = "Cher" typeface = "Plantagenet Cherokee" /> '; t [t.length] =' <a: font script = "Yiii" typeface = "Microsoft Yi Baiti" /> '; t [t. longitud] = '<a: font script = "Tibt" typeface = "Microsoft Himalaya" />'; t [t.length] = '<a: font script = "Thaa" typeface = "MV Boli" />'; t [t.length] = '<a: font script = "Deva" typeface = "Mangal" />'; t [t.length] = '<a: font script = "Telu" typeface = "Gautami" /> '; t [t.length] =' <a: font script = "Taml" typeface = "Latha" /> '; t [t.length] =' <a:font script = "Syrc" typeface = "Estrangelo Edessa" /> '; t [t.length] =' <a: font script = "Orya" typeface = "Kalinga" /> '; t [t.length] =' <a: font script = "Mlym" typeface = "Kartika" /> '; t [t.length] =' <a: font script = "Laoo" typeface = "DokChampa" /> '; t [t.length] = '<a: font script = "Sinh" typeface = "Iskoola Pota" />'; t [t.length] = '<a: font script = "Mong" typeface = "Mongolian Baiti" />'; t [ t.length] = '<a: font script = "Viet" typeface = "Times New Roman" />'; t [t.length] = '<a: font script = "Uigh" typeface = "Microsoft Uighur" / > '; t [t.length] =' <a: font script = "Geor" typeface = "Sylfaen" /> '; t [t.length] = "</a:majorFont>";t[t.lengthfont>="<a:minorFont>";t[t.lengthfont>='<a:latin typeface = "Calibri" /> '; t [t.length] = '<a: ea typeface = "" />'; t [t.length] = '<a: cs typeface = "" />'; t [t.length] = '<a: font script = "Jpan" typeface = "ＭＳ Ｐ ゴ シ ッ ク" />';t[t.lengthfont>='<a:font script = "Hang" typeface = "맑은 고딕" />';t[t.lengthfont>='<a:font script = "Hans" typeface = "宋体" />';t[t.lengthfont>='<a:font script = "Hant" typeface = "新 細 明 體" />';t[t.lengthfont>= '<a: font script = "Arab" typeface = "Arial" />'; t [t.length] = '<a: font script = "Hebr" typeface = "Arial" />'; t [t.length ] = '<a: font script = "Thai" typeface = "Tahoma "/> '; t [t.length] =' <a: font script =" Ethi "typeface =" Nyala "/> '; t [t.length] =' <a: font script =" Beng "typeface = "Vrinda" /> '; t [t.length] =' <a: font script = "Gujr" typeface = "Shruti" /> '; t [t.length] =' <a: font script = "Khmr "typeface =" DaunPenh "/> '; t [t.length] =' <a: font script =" Knda "typeface =" Tunga "/> '; t [t.length] =' <a: font script = "Guru" typeface = "Raavi" /> '; t [t.length] =' <a: font script = "Cans" typeface = "Euphemia" /> '; t [t.length] =' <a: font script = "Cher" typeface = "Plantagenet Cherokee" /> '; t [t.length] =' <a: font script = "Yiii" typeface = "Microsoft Yi Baiti" /> ';t [t.length] = '<a: font script = "Tibt" typeface = "Microsoft Himalaya" />'; t [t.length] = '<a: font script = "Thaa" typeface = "MV Boli" />';t[t.lengthfont>='<a:font script = "Deva" typeface = "Mangal" /> '; t [t.length] =' <a: font script = "Telu" typeface = " Gautami "/> '; t [t.length] =' <a: font script =" Taml "typeface =" Latha "/> '; t [t.length] =' <a: font script =" Syrc "typeface = "Estrangelo Edessa" /> '; t [t.length] =' <a: font script = "Orya" typeface = "Kalinga" /> '; t [t.length] =' <a: font script = " Mlym "typeface =" Kartika "/> '; t [t.length] =' <a: font script =" Laoo "typeface =" DokChampa "/> '; t [t.length] =' <a: font script = "Sinh" typeface = "Iskoola Pota" /> '; t [t.length] =' <a: font script = "Mong" typeface = "Mongolian Baiti" /> '; t [t.length ] = '<a: font script = "Viet" typeface = "Arial" />'; t [t.length] = '<a: font script = "Uigh" typeface = "Microsoft Uighur" />'; t [ t.length] = '<a: font script = "Geor" typeface = "Sylfaen" />'; t [t.length] = "</ a: minorFont>"; t [t.length] = "</ a: fontScheme> "; t [t.length] = '<a: fmtScheme name =" Office ">'; t [t.length] =" <a: fillStyleLst> "; t [t.length] = '< a: solidFill> <a: schemeClr val = "phClr" /> </ a: solidFill> '; t [t.length] =' <a: gradFill rotWithShape = "1"> '; t [t.length] = "<a:gsLst> "; t [t.length] = '<a: gs pos =" 0 "> <a: schemeClr val =" phClr "> <a: tint val =" 50000 "/> <a: satMod val =" 300000 "/> </ a: schemeClr> </ a: gs> '; t [t.length] =' <a: gs pos =" 35000 "> <a: schemeClr val =" phClr "> <a: tinte val = "37000" /> <a: satMod val = "300000" /> </ a: schemeClr> </ a: gs> '; t [t.length] =' <a: gs pos = "100000"> <a: schemeClr val = "phClr"> <a: tint val = "15000" /> <a: satMod val = "350000" /> </ a: schemeClr> </ a: gs> '; t [t. length] = "</ a: gsLst>"; t [t.length] = '<a: lin ang = "16200000" scaled = "1" />'; t [t.length] = "</ a: gradFill> "; t [t.length] = '<a: gradFill rotWithShape ="1 "> '; t [t.length] =" <a: gsLst> "; t [t.length] =' <a: gs pos =" 0 "> <a: schemeClr val =" phClr "> <a : tint val = "100000" /> <a: shade val = "100000" /> <a: satMod val = "130000" /> </ a: schemeClr> </ a: gs> '; t [t.length ] = '<a: gs pos = "100000"> <a: schemeClr val = "phClr"> <a: tint val = "50000" /> <a: shade val = "100000" /> <a: satMod val = "350000" /> </ a: schemeClr> </ a: gs> '; t [t.length] = "</ a: gsLst>"; t [t.length] =' <a: lin ang = "16200000" escalado = "0" /> '; t [t.length] = "</ a: gradFill>"; t [t.length] = "</ a: fillStyleLst>"; t [t.length] = "<a: lnStyleLst>"; t [t.length] = '<a: ln w = "9525"cap = "flat" cmpd = "sng" algn = "ctr"> <a: solidFill> <a: schemeClr val = "phClr"> <a: shade val = "95000" /> <a: satMod val = "105000 "/> </ a: schemeClr> </ a: solidFill> <a: prstDash val =" solid "/> </ a: ln> '; t [t.length] =' <a: ln w =" 25400 "cap =" flat "cmpd =" sng "algn =" ctr "> <a: solidFill> <a: schemeClr val =" phClr "/> </ a: solidFill> <a: prstDash val =" solid "/> </ a: ln> '; t [t.length] =' <a: ln w = "38100" cap = "flat" cmpd = "sng" algn = "ctr"> <a: solidFill> <a: schemeClr val = "phClr" /> </ a: solidFill> <a: prstDash val = "solid" /> </ a: ln> '; t [t.length] = "</ a: lnStyleLst>";t [t.length] = "<a: effectStyleLst>"; t [t.length] = "<a: effectStyle>"; t [t.length] = "<a: effectLst>"; t [t.length ] = '<a: outsideShdw blurRad = "40000" dist = "20000" dir = "5400000" rotWithShape = "0"> <a: srgbClr val = "000000"> <a: alpha val = "38000" /> < /a:srgbClr></a:outerShdw>';t[t.lengthfont>="</a:effectLst>";t[t.lengthfont>="</a:effectStyle>";t[t.length ] = "<a: effectStyle>"; t [t.length] = "<a: effectLst>"; t [t.length] = '<a: externalShdw blurRad = "40000" dist = "23000" dir = " 5400000 "rotWithShape =" 0 "> <a: srgbClr val =" 000000 "> <a: alpha val =" 35000 "/> </ a: srgbClr> </ a: outsideShdw> '; t [t.length] = "</a:effectLst>";t[t.lengthfont>="</a:effectStyle>";t[t.lengthfont>="<a:effectStyle>";t[t.lengthfont>="<a:effectLst > "; t [t.length] = '<a: outsideShdw blurRad =" 40000 "dist =" 23000 "dir =" 5400000 "rotWithShape =" 0 "> <a: srgbClr val =" 000000 "> <a: alpha val = "35000" /> </ a: srgbClr> </ a: outsideShdw> '; t [t.length] = "</ a: effectLst>"; t [t.length] =' <a: scene3d> <a: camera prst = "orthographicFront"> <a: rot lat = "0" lon = "0" rev = "0" /> </ a: camera> <a: lightRig rig = "threePt" dir = "t "> <a: rot lat =" 0 "lon =" 0 "rev =" 1200000 "/> </ a: lightRig> </ a: scene3d> '; t [t.length] =' <a: sp3d> <a:biselT w = "63500" h = "25400" /> </ a: sp3d> '; t [t.length] = "</ a: effectStyle>"; t [t.length] = "</ a: effectStyleLst > "; t [t.length] =" <a: bgFillStyleLst> "; t [t.length] = '<a: solidFill> <a: schemeClr val =" phClr "/> </ a: solidFill>'; t [t.length] = '<a: gradFill rotWithShape = "1">'; t [t.length] = "<a: gsLst>"; t [t.length] = '<a: gs pos = " 0 "> <a: schemeClr val =" phClr "> <a: tint val =" 40000 "/> <a: satMod val =" 350000 "/> </ a: schemeClr> </ a: gs> '; t [t.length] = '<a: gs pos = "40000"> <a: schemeClr val = "phClr"> <a: tint val = "45000" /> <a: shade val = "99000" /> < a: satMod val = "350000" /> </ a:schemeClr> </ a: gs> '; t [t.length] =' <a: gs pos = "100000"> <a: schemeClr val = "phClr"> <a: sombra val = "20000" /> < a: satMod val = "255000" /> </ a: schemeClr> </ a: gs> '; t [t.length] = "</ a: gsLst>"; t [t.length] =' <a : ruta ruta = "círculo"> <a: fillToRect l = "50000" t = "- 80000" r = "50000" b = "180000" /> </ a: ruta> '; t [t.length] = "</ a: gradFill>"; t [t.length] = '<a: gradFill rotWithShape = "1">'; t [t.length] = "<a: gsLst>"; t [t.length] = '<a: gs pos = "0"> <a: schemeClr val = "phClr"> <a: tint val = "80000" /> <a: satMod val = "300000" /> </ a: schemeClr> </ a: gs> '; t [t.length] =' <a: gs pos = "100000 "> <a: schemeClr val =" phClr "> <a: shade val =" 30000 "/> <a: satMod val =" 200000 "/> </ a: schemeClr> </ a: gs> '; t [t.length] = "</ a: gsLst>"; t [t.length] = '<a: path path = "circle"> <a: fillToRect l = "50000" t = "50000" r = " 50000 "b =" 50000 "/> </ a: ruta> '; t [t.length] =" </ a: gradFill> "; t [t.length] =" </ a: bgFillStyleLst> "; t [t.length] = "</ a: fmtScheme>"; t [t.length] = "</ a: themeElements>"; t [t.length] = "<a: objectDefaults>"; t [t. length] = "<a: spDef>"; t [t.length] = '<a: spPr /> <a: bodyPr /> <a: lstStyle /> <a: style> <a: lnRef idx = "1 "> <a: schemeClr val =" acento1 "/> </ a: lnRef> <a:fillRef idx = "3"> <a: schemeClr val = "accent1" /> </ a: fillRef> <a: effectRef idx = "2"> <a: schemeClr val = "accent1" /> </ a: effectRef > <a: fontRef idx = "minor"> <a: schemeClr val = "lt1" /> </ a: fontRef> </ a: style> '; t [t.length] = "</ a: spDef> "; t [t.length] =" <a: lnDef> "; t [t.length] = '<a: spPr /> <a: bodyPr /> <a: lstStyle /> <a: style> <a : lnRef idx = "2"> <a: schemeClr val = "accent1" /> </ a: lnRef> <a: fillRef idx = "0"> <a: schemeClr val = "accent1" /> </ a: fillRef> <a: effectRef idx = "1"> <a: schemeClr val = "acento1" /> </ a: effectRef> <a: fontRef idx = "menor"> <a: schemeClr val = "tx1" /> </ a:fontRef> </ a: style> '; t [t.length] = "</ a: lnDef>"; t [t.length] = "</ a: objectDefaults>"; t [t.length] = " <a: extraClrSchemeLst /> "; t [t.length] =" </ a: theme> "; return t.join (" ")} función Sn () {} función Cn (e, r, t, a) {if (! e) return e; var n = a || {}; var i = false, s = false; Jr (e, function l (e, r, t) {if (s) return; switch (t ) {caso 359:; caso 363:; caso 364:; caso 366:; caso 367:; caso 368:; caso 369:; caso 370:; caso 371:; caso 472:; caso 577:; caso 578 :; caso 579:; caso 580:; caso 581:; caso 582:; caso 583:; caso 584:; caso 585:; caso 586:; caso 587: descanso; caso 35: i = verdadero; descanso; caso 36: i = false; break; default: if ((r || ""). indexOf ("Begin")> 0) {} else if ((r || ""). indexOf ("End")> 0) {} de lo contrario, si (! i || n.WTF) arroja un nuevo error ("Registro inesperado" + t.toString (16) + "" + r);}}, n)} Kt.IMG = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image"; Kt.DRAW = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing"; función _n (e , r) {if (! e) return "??"; var t = (e.match (/ <c: chart [^>] * r: id = "([^"] *) "/) || ["", ""]) [1]; devuelve r ["! Id"] [t] .Target} var An = 1024; función En (e, r) {var t = [21600,21600]; var a = ["m0,0l0", t [1], t [0], t [1], t [0], "0xe"]. join (","); var n = [sr ("xml", nulo, {"xmlns: v": cr.v, "xmlns: o": cr.o, "xmlns: x": cr.x, "xmlns: mv": cr.mv}). reemplazar (/ \ / > /, ">"), sr ("o: shapelayout", sr ("o: idmap", null, {"v: ext": "edit", data: e}), {"v: ext": "edit"}), sr ("v: shapetype", [sr ("v:trazo ", nulo, {joinstyle:" mitre "}), sr (" v: ruta ", nulo, {gradientshapeok:" t "," o: connecttype ":" rect "})]. join (" "), {id: "_ x0000_t202", "o: spt": 202, coordsize: t.join (","), ruta: a})]; while (An <e * 1e3) An + = 1e3; r.forEach (función (e) {var r = ht (e [0]); var t = {color2: "# BEFF82", escriba: "gradiente"}; if (t.type == "gradiente") t.angle = "- 180 "; var a = t.type ==" gradient "? Sr (" o: fill ", null, {type:" gradientUnscaled "," v: ext ":" view "}): null; var i = sr ("v: fill", a, t); var s = {on: "t", oscurecido: "t"}; ++ An; n = n.concat (["<v: shape" + ir ({ id: "_ x0000_s" + An, escriba: "#_ x0000_t202", estilo: "posición: absoluto; margen-izquierda: 80pt; margen-superior: 5pt; ancho: 104pt; altura: 64pt;z-index: 10 "+ (e [1] .hidden?"; visibilidad: oculto ":" "), color de relleno:" # ECFAD4 ", strokecolor:" # edeaa1 "}) +"> ", i, sr ( "v: shadow", null, s), sr ("v: ruta", null, {"o: connecttype": "none"}), '<v: textbox> <div style = "text-align: left "> </div> </ v: textbox> ',' <x: ClientData ObjectType =" Note "> '," <x: MoveWithCells /> "," <x: SizeWithCells /> ", nr (" x: Ancla ", [r.c + 1,0, r.r + 1,0, r.c + 3,20, r.r + 5,20] .join (", ")), nr (" x: Autocompletar "," Falso "), nr (" x: Row ", String (rr)), nr (" x: Column ", String (rc)), e [1] .hidden?" ":" <X: Visible /> "," </ x: ClientData> "," </ v: shape> "])}); n.push (" </xml> ");return n.join ("")} Kt.CMNT = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments"; función Tn (e, r) {var t = Array.isArray (e) ; var a; r.forEach (function (r) {var n = ht (r.ref); if (t) {if (! e [nr]) e [nr] = []; a = e [nr] [nc]} else a = e [r.ref]; if (! a) {a = {t: "z"}; if (t) e [nr] [nc] = a; else e [r.ref ] = a; var i = vt (e ["! ref"] || "BDWGO1000001: A1"); if (isr> nr) isr = nr; if (ier <nr) ier = nr; if (isc> nc ) isc = nc; if (iec <nc) iec = nc; var s = pt (i); if (s! == e ["! ref"]) e ["! ref"] = s} if (! ac) ac = []; var l = {a: r.author, t: rt, r: rr}; if (rh) lh = rh; acpush (l)})} función Fn (e, r) {if (e.match (/ <(?: \ w + :)? comments * \ /> /)) return []; var t = []; var a = []; var n = e.match (/ <(? : \ w + :)? autores> ([\ s \ S] *) <\ / (?: \ w + :)? autores> /); if (n && n [1]) n [1] .split (/ <\ / \ w * :? autor> /).forEach (function (e) {if (e === "" || e.trim () === "") return; var r = e.match (/ <(?: \ w + :)? author [^ >] *> (. *) /); if (r) t.push (r [1])}); var i = e.match (/ <(?: \ w + :)? commentList> ([\ s \ S] *) <\ / (?: \ W + :)? CommentList> /); if (i && i [1]) i [1] .split (/ <\ / \ w * :? comment> /). ForEach (función (e) {if (e === "" || e.trim () === "") return; var n = e.match (/ <(?: \ w + :)? comment [^> ] *> /); if (! n) return; var i = De (n [0]);
var s = {author: i.authorId && t [i.authorId] || "sheetjsghost", ref: i.ref, guid: i.guid}; var l = ht (i.ref); if (r.sheetRows && r.sheetRows <= lr) return; var o = e.match (/ <(?: \ w + :)? text> ([\ s \ S] *) <\ / (?: \ w + :)? text> /); var f = !! o && !! o [1] && Ea (o [1]) || {r: "", t: "", h: ""}; sr = fr; if (fr == "<t > </t> ") ft = fh =" "; st = ftreplace (/ \ r \ n / g," \ n "). reemplazar (/ \ r / g," \ n "); if (r. cellHTML) sh = fh; a.push (s)}); devuelve a} var On = sr ("comentarios", nulo, {xmlns: fr.main [0]}); función Dn (e) {var r = [Ae, On]; var t = []; r.push ("<authors>"); e.forEach (function (e) {e [1] .forEach (function (e) {var a = Be (ea ); if (t.indexOf (a)> - 1) return; t.push (a); r.push ("<author>" + a + "</author>")})}); r.push ( "</authors>"); r.push ("<commentList> "); e.forEach (function (e) {e [1] .forEach (function (a) {r.push ('<comment ref ="' + e [0] + '"authorId ="' + t.indexOf (Be (aa)) + '"> <texto>'); r.push (nr (" t ", at == null?" ": Be (at))); r.push (" </text> </comment> ")})}); r.push (" </commentList> "); if (r.length> 2) {r [r.length] =" </comments> "; r [1] = r [1] .replace ("/>", ">")} return r.join ("")} var Mn = "application / vnd.ms-office.vbaProject"; función Pn (e ) {var r = j.utils.cfb_new ({root: "R"}); e.FullPaths.forEach (function (t, a) {if (t.slice (-1) === "/" || ! t.match (/ _ VBA_PROJECT_CUR /)) return; var n = t.replace (/ ^ [^ \ /] * /, "R"). replace (/ \ / _ VBA_PROJECT_CUR \ u0000 * /, ""); j .utils.cfb_add (r, n, e.FileIndex [a] .content)});return j.write (r)} function Rn (e, r) {r.FullPaths.forEach (function (t, a) {if (a == 0) return; var n = t.replace (/ [^ \ / ] * [\ /] /, "/ _ VBA_PROJECT_CUR /"); if (n.slice (-1)! == "/") j.utils.cfb_add (e, n, r.FileIndex [a] .content) })} var Nn = ["xlsb", "xlsm", "xlam", "biff8", "xla"]; Kt.DS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet "; Kt.MS =" http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet "; function In () {return {"! Type ":" dialog "}} function Ln () {return { "! type": "dialog"}} function Bn () {return {"! type": "macro"}} function zn () {return {"! type": "macro"}} var Wn = function () {var e = / (^ | [^ A-Za-z _]) R (\ [? -? \ d + \] | [1-9] \ d * |) C (\ [? -? \ d + \] | [1-9] \ d * |) (?! [A-Za-z0-9 _]) / g; var r = {r: 0, c: 0};función t (e, t, a, n) {var i = falso, s = falso; if (a.length == 0) s = true; sino if (a.charAt (0) == "[") { s = verdadero; a = a.slice (1, -1)} if (n.length == 0) i = true; else if (n.charAt (0) == "[") {i = true; n = n.slice (1, -1)} var l = a.length> 0? parseInt (a, 10) | 0: 0, o = n.length> 0? parseInt (n, 10) | 0: 0; if (i) o + = rc; else - o; if (s) l + = rr; else - l; devuelve t + (i? ":" $ ") + lt (o) + (s?" ": "$") + en (l)} función de retorno a (n, i) {r = i; retorno n.replace (e, t)}} (); var $ n = / (^ | [^ ._ A- Z0-9]) ([$]?) ([AZ] {1,2} | [AW] [AZ] {2} | X [AE] [AZ] | XF [AD]) ([$]?) ([1-9] \ d {0,5} | 10 [0-3] \ d {4} | 104 [0-7] \ d {3} | 1048 [0-4] \ d {2} | 10485 [0-6] \ d | 104857 [0-6]) (?! [_. \ (A-Za-z0-9]) / g; var Un = function () {función de retorno e (r, t ) {return r.replace ($ n, función (e, r, a, n, i, s) {var l = st (n) - (a? 0: tc); var o = tt (s) - ( i? 0: tr); var f = o == 0? "" :! i? "[" + o + "]": o + 1; var c = l == 0? "" :! a? "["+ l +"] ": l + 1; return r +" R "+ f +" C "+ c})}} (); function jn (e, r) {return e.replace ($ n, function (e , t, a, n, i, s) {return t + (a == "$"? a + n: lt (st (n) + rc)) + (i == "$"? i + s: at (tt (s) + rr))})} función Hn (e, r, t) {var a = dt (r), n = as, i = ht (t); var s = {r: ir-nr , c: ic-nc}; devuelve jn (e, s)} función Vn (e) {if (e.length == 1) devuelve false; devuelve true} función Xn (e) {return e.replace (/ _ xlfn \ ./ g, "")} var Gn = {}; var Yn = {}; Kt.WS = ["http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet", "http: / /purl.oclc.org/ooxml/officeDocument/relationships/worksheet"font>;var Jn = typeof Map! == "undefined"; función Zn (e, r, t) {var a = 0, n = e.length; if (t) {if (Jn? t.has (r): t.hasOwnProperty (r)) {var i = Jn? t.get (r): t [r]; for (; a <i.length; ++ a) {if (e [i [a]]. t === r) {e.Count ++; devuelve i [a]}}}} else para (; a <n; ++ a) {if ( e [a].t === r) {e.Count ++; devuelve a}} e [n] = {t: r}; e.Count ++; e.Unique ++; if (t) {if (Jn) {if (! t.has (r)) t.set (r, []); t.get (r) .push (n)} else {if (! t.hasOwnProperty (r)) t [r] = []; t [r] .push (n)}} return n} función qn (e, r) {var t = {min: e + 1, max: e + 1}; var a = -1; if (r.MDW) Ua = r .MDW; if (r.width! = Null) t.customWidth = 1; else if (r.wpx! = Null) a = Ha (r.wpx); else if (r.wch! = Null) a = r .wch; if (a> -1) {t.width = Va (a); t.customWidth = 1} más if (r.width! = null) t.width = r.width; if (r.hidden) t.hidden = verdadero; retorno t} función Kn (e, r) {if (! e) return; var t = [. 7, .7, .75, .75, .3, .3]; if (r == "xlml") t = [1,1,1,1, .5, .5]; if (e.left == null) e.left = t [0]; if (e.right == null ) e.right = t [1]; if (e.top == null) e.top = t [2]; if (e.bottom == null) e.bottom = t [3]; if (e. header == null) e.header = t [4]; if (e.footer == null) e.footer = t [5]} function Qn (e, r, t) {var a = t.revssf [rz ! = null? rz: "General"]; var n = 60, i = e.length; if (a == null && t.ssf) {for (; n <392;++ n) if (t.ssf [n] == null) {P.load (rz, n); t.ssf [n] = rz; t.revssf [rz] = a = n; break}} para (n = 0; n! = i; ++ n) if (e [n] .numFmtId === a) devuelve n; e [i] = {numFmtId: a, fontId: 0, fillId: 0, borderId: 0, xfId: 0, applyNumberFormat: 1}; return i} function ei (e, r, t, a, n, i) {try {if (a.cellNF) ez = P._table [r]} catch (s ) {if (a.WTF) throw s} if (et === "z") return; if (et === "d" && typeof ev === "string") ev = se (ev); if ( ! a || a.cellText! == falso) intente {if (P._table [r] == null) P.load (I [r] || "General", r); if (et === " e ") ew = ew || BErr [ev]; de lo contrario if (r === 0) {if (et ===" n ") {if ((ev | 0) === ev) ew = P. _general_int (ev); else ew = P._general_num (ev)} else if (et === "d") {var l = re (ev); if ((l | 0) === l) ew = P ._general_int (l); else ew = P._general_num (l)} else if (ev === undefined) return ""; else ew = P._general (ev, Yn)} else if (et === "d ") ew = P.format (r, re (ev),Yn); else ew = P.format (r, ev, Yn)} catch (s) {if (a.WTF) throw s} if (! A.cellStyles) return; if (t! = Null) try {es = i.Fills [t]; if (esfgColor && e.s.fgColor.theme &&! esfgColor.rgb) {esfgColor.rgb = Ba (n.themeElements.clrScheme [esfgColor.theme] .rgb, esfgColor.tint || 0); if (a.WTF) esfgColor.raw_rgb = n.themeElements.clrScheme [esfgColor.theme] .rgb} if (esbgColor && e.s.bgColor.theme) {esbgColor.rgb = Ba (n.themeElements.clrScheme [es. .rgb, esbgColor.tint || 0); if (a.WTF) esbgColor.raw_rgb = n.themeElements.clrScheme [esbgColor.theme] .rgb}} catch (s) {if (a.WTF && i.Fills) throw s }} función ri (e, r, t) {if (e && e ["! ref"]) {var a = vt (e ["! ref"]); if (aec <asc || aer <asr) lanzar nuevo Error ("Rango incorrecto (" + t + "):" + e ["! Ref"])}} función ti (e, r) {var t = vt (r); if (tsr <= ter && t.sc <= tec && t.sr> = 0 && t.sc> = 0) e ["! ref"] = pt (t)} var ai = / <(?: \ w :)? mergeCell ref = "[A-Z0- 9:] + "\ s * [\ /]?> / G; var ni = / <(?: \ W + :)? SheetData [^>] *> ([\ s \ S] *) <\ / ( ?: \ w + :)? sheetData> /; var ii = / <(?: \ w :)? hyperlink [^>] *> / gm; var si = / "(\ w *: \ w *)" / ; var li = / <(?: \ w :)? col \ b [^>] * [\ /]?> / g; var oi = / <(?: \ w :)? autoFilter [^>] * ([\ /] |> ([\ s \ S] *) <\ / (?: \ w :)? autoFilter)> / g; var fi = / <(?: \ w :)? pageMargins [^> ] * \ /> / g; var ci = / <(?: \ w :)? sheetPr \ b (?: [^> az] [^>] *)? \ /> /; var hi = / <( ?: \ w :)? sheetViews [^>] * (?: [\ /] |> ([\ s \ S] *) <\ / (?: \ w :)? sheetViews)> /; function ui ( e, r, t, a, n, i, s) {if (! e) return e; if (! a) a = {"! id": {}}; if (m! = null && r.dense == nulo) r.dense = m; var l = r.dense? []: {}; var o = {s: {r: 2e6, c: 2e6}, e: {r: 0, c: 0}}; var f = "", c = ""; var h = e.match (ni); if (h) {f = e.slice (0, h.index); c = e.slice (h.index + h [0] .length)} else f = c = e; var u = f.match (ci); if (u) pi (u [0], l, n, t); var d = (f.match (/ <(?: \ w * :)? dimension /) || {index: -1}). index; if (d> 0) {var p = f.slice (d, d + 50) .match (si); if (p) ti (l, p [1])} var v = f.match (hi); if (v && v [1]) Ei (v [1], n); var g = []; if (r.cellStyles) {var b = f.match (li); if (b) xi (g, b)} if (h) Oi (h [1], l, r, o, i, s); var w = c.match (oi); if (w) l [" ! autofiltro "] = Ci (w [0]); var k = []; var y = c.match (ai); if (y) para (d = 0; d! = y.length; ++ d) k [d] = vt (y [d] .slice (y [d] .indexOf ('"') + 1)); var x = c.match (ii); if (x) wi (l, x, a); var S = c.match (fi); if (S) l ["! margins"] = ki (De (S [0])); if (! l ["! ref"] && o.ec> = osc && o.er> = osr) l ["! ref"] = pt (o); if (r.sheetRows> 0 && l ["! ref"]) {var C = vt (l ["! ref"]); if (r.sheetRows <= + Cer) {Cer = r.sheetRows-1; if (C.er> oer) Cer = oer; if (Cer <Csr) Csr = Cer; if (Cec> oec) Cec = oec; if (Cec <Csc) Csc = Cec; l ["! fullref"] = l ["! ref "]; l ["! ref "] = pt (C)}} if (g.length> 0) l ["! cols "] = g; if (k.length> 0) l ["! merges " ] = k; return l} función di (e) {if (e.length === 0) return ""; var r = '<mergeCells count = "' + e.length + '">'; for (var t = 0; t! = E.length; ++ t) r + = '<mergeCell ref = "' + pt (e [t]) + '" />'; return r + "</mergeCells>"} function pi ( e, r, t, a) {var n = De (e); if (! t.Sheets [a]) t.Sheets [a] = {}; if (n.codeName) t.Sheets [a]. CodeName = n.codeName} función vi (e, r, t, a, n) {var i = false; var s = {}, l = null; if (a.bookType! == "xlsx" && r.vbaraw) {var o = r.SheetNames [t]; prueba {if (r.Workbook) o = r.Workbook.Sheets [t] .CodeName || o} catch (f) {} i = true; s.codeName = Be (o)} if (! i &&! l) return; n [n.length] = sr ("sheetPr", l, s)} var mi = ["objetos", "escenarios", "selectLockedCells", "selectUnlockedCells"]; var gi = ["formatColumns", "formatRows", "formatCells", "insertColumns", "insertRows", "insertHyperlinks", "deleteColumns", "deleteRows", "sortRows", "sort", "autoFilter", " tablas dinámicas "]; función bi (e) {var r = {hoja: 1}; mi.forEach (función (t) {if (e [t]! = nulo && e [t]) r [t] =" 1 "} ); gi.forEach (function (t) {if (e [t]! = null &&! e [t]) r [t] = "0"}); if (e.password) r.password = crypto_CreatePasswordVerifier_Method1 (e .password) .toString (16) .toUpperCase (); return sr ("sheetProtection", null, r)} function wi (e, r, t) {var a = Array.isArray (e); for (var n = 0; n! = R.length;++ n) {var i = De (Xe (r [n]), verdadero); if (! i.ref) return; var s = ((t || {}) ["! id"] || [ ]) [i.id]; if (s) {i.Target = s.Target; if (i.location) i.Target + = "#" + i.location} else {i.Target = "#" + i .location; s = {Target: i.Target, TargetMode: "Internal"}} i.Rel = s; if (i.tooltip) {i.Tooltip = i.tooltip; delete i.tooltip} var l = vt ( i.ref); for (var o = lsr; o <= ler; ++ o) for (var f = lsc; f <= lec; ++ f) {var c = ut ({c: f, r: o}); if (a) {if (! e [o]) e [o] = []; if (! e [o] [f]) ​​e [o] [f] = {t: "z" , v: indefinido}; e [o] [f] .l = i} más {if (! e [c]) e [c] = {t: "z", v: indefinido}; e [c]. l = i}}}} function ki (e) {var r = {}; ["left", "right", "top", "bottom", "header", "footer"]. forEach (function (t ) {if (e [t]) r [t] = parseFloat (e [t])}); return r} función yi (e) {Kn (e); return sr ("pageMargins", null, e)} función xi (e, r) {var t = falso; para (var a = 0; a!= r.length; ++ a) {var n = De (r [a], true); if (n.hidden) n.hidden = Ve (n.hidden); var i = parseInt (n.min, 10 ) -1, s = parseInt (n.max, 10) -1; eliminar n.min; eliminar n.max; n.width = + n.width; if (! T && n.width) {t = true; Ga ( n.width)} Ya (n); while (i <= s) e [i ++] = oe (n)}} función Si (e, r) {var t = ["<cols>"], a; para (var n = 0; n! = r.length; ++ n) {if (! (a = r [n])) continuar; t [t.length] = sr ("col", null, qn (n , a))} t [t.length] = "</cols>"; devuelve t.join ("")} función Ci (e) {var r = {ref: (e.match (/ ref = "( [^ "] *)" /) || []) [1]}; devuelve r} función _i (e, r, t, a) {var n = typeof e.ref == "string"? E.ref : pt (e.ref); if (! t.Workbook) t.Workbook = {Hojas: []}; if (! t.Workbook.Names) t.Workbook.Names = []; var i = t.Workbook .Nombres; var s = dt (n); if (ssr == ser) {ser = dt (r ["! Ref"]). Er; n = pt (s)} para (var l = 0; l < i.length; ++ l) {var o = i [l]; if (o.Name! = "_ xlnm._FilterDatabase ") continuar; if (o.Sheet! = A) continue; o.Ref =" '"+ t.SheetNames [a] +"'! "+ N; break} if (l == i.length) i .push ({Nombre: "_ xlnm._FilterDatabase", Hoja: a, Ref: "'" + t.SheetNames [a] + "'!" + n}); return sr ("autoFilter", null, {ref: n})} var Ai = / <(?: \ w :)? sheetView (?: [^> az] [^>] *)? \ /?> /; función Ei (e, r) {if (! r.Views) r.Views = [{}]; (e.match (Ai) || []). forEach (function (e, t) {var a = De (e); if (! r.Views [ t]) r.Views [t] = {}; if (Ve (a.rightToLeft)) r.Views [t] .RTL = true})} función Ti (e, r, t, a) {var n = {workbookViewId: "0"}; if (((((a || {}). Workbook || {}). Vistas || []) [0]) n.rightToLeft = a.Workbook.Views [0]. RTL? "1": "0"; return sr ("sheetViews", sr ("sheetView", null, n), {})} función Fi (e, r, t, a) {if (ev === undefined && e.f === undefined || et === "z") return ""; var n =" "; var i = et, s = ev; if (et! ==" z ") switch (et) {case" b ": n = ev?" 1 ":" 0 "; break ; case "n": n = "" + ev; break; case "e": n = BErr [ev]; break; case "d": if (a && a.cellDates) n = se (ev, -1). toISOString (); else {e = oe (e); et = "n"; n = "" + (ev = re (se (ev)))}} if (typeof ez === "undefined") ez = P ._table [14]; break; default: n = ev; break;} var l = nr ("v", Be (n)), o = {r: r}; var f = Qn (a.cellXfs, e , a); if (f! == 0) os = f; switch (et) {case "n": break; case "d": ot = "d"; break; case "b": ot = "b "; break; case" e ": ot =" e "; break; case" z ": break; default: if (ev == null) {delete et; break} if (a && a.bookSST) {l = nr ( "v", "" + Zn (a.Strings, ev, a.revStrings)); ot = "s"; break} ot = "str "; break;} if (et! = i) {et = i; ev = s} if (ef) {var c = eF && e.F.slice (0, r.length) == r? {t:" array ", ref: eF}: null; l = sr (" f ", Be (ef), c) + (ev! = null? l:" ")} if (el) t ["! links "]. push ([r, el]); if (ec) t ["! comments"]. push ([r, ec]); return sr ("c", l, o)} var Oi = function () {var e = / <(?: \ w + :)? c [>] /, r = / <\ / (?: \ w + :)? row> /; var t = / r = ["'] ([^" '] *) ["'] /, a = / <(?: \ w + :)? is> ([\ S \ s] *?) <\ / (?: \ w + :)? is> /; var n = / ref = ["'] ([^"'] *) ["'] /; var i = qe (" v "), s = qe (" f "); función de retorno l (o, f, c, h, u, d) {var p = 0, v = "", m = [], g = [], b = 0, w = 0, k = 0, y = "", x; var S , C = 0, _ = 0; var A, E; var T = 0, F = 0; var O = Array.isArray (d.CellXf), D; var M = []; var R = []; var N = Array.isArray (f); var I = [], L = {}, B = false; for (var z = o.split (r), W = 0, $ = z.length; W! = $ ;++ W) {v = z [W] .trim (); var U = v.length; if (U === 0) continue; for (p = 0; p <U; ++ p) if (v .charCodeAt (p) === 62) break; ++ p; S = De (v.slice (0, p), true); C = Sr! = null? parseInt (Sr, 10): C + 1; _ = - 1; if (c.sheetRows && c.sheetRows <C) continuar; if (hsr> C-1) hsr = C-1; if (her <C-1) her = C-1; if (c && c.cellStyles ) {L = {}; B = falso; if (S.ht) {B = verdadero; L.hpt = parseFloat (S.ht); L.hpx = Ka (L.hpt)} if (S.hidden = = "1") {B = verdadero; L.hidden = verdadero} if (S.outlineLevel! = Null) {B = verdadero; L.level = + S.outlineLevel} if (B) I [C-1] = L} m = v.slice (p) .split (e); for (var j = 0; j! = M.length; ++ j) if (m [j] .trim (). CharAt (0)! = "<") break; m = m.slice (j); for (p = 0; p! = m.length; ++ p) {v = m [p] .trim (); if (v.length === 0) continuar; g = v.match (t); b = p; w = 0; k = 0; v = "<c" + (v.slice (0,1) == "<"? ">": "") + v; if (g! = null && g.length === 2) {b = 0; y = g [1]; for (w = 0; w! = y.length; ++ w) {if ((k = y.charCodeAt (w) -64) <1 || k> 26) break; b = 26 * b + k} - b; _ = b} else ++ _; for (w = 0; w! = v.length ; ++ w) if (v.charCodeAt (w) === 62) break; ++ w; S = De (v.slice (0, w), true); if (! Sr) Sr = ut ({ r: C-1, c: _}); y = v.slice (w); x = {t: ""}; if ((g = y.match (i))! = null && g [1]! = = "") xv = Ne (g [1]); if (c.cellFormula) {if ((g = y.match (s))! = null && g [1]! == "") {xf = Xn ( Ne (Xe (g [1]))); if (g [0] .indexOf ('t = "array"')> - 1) {xF = (y.match (n) || []) [1 ]; if (xFindexOf (":")> - 1) M.push ([vt (xF), xF])} else if (g [0] .indexOf ('t = "shared"')> - 1) {E = De (g [0]); R [parseInt (E.si, 10)] = [E, Xn (Ne (Xe (g [1]))), Sr]}} más si (g = y .match (/ <f [^>] * \ /> /)) {E = De (g [0]); if (R [E.si]) xf = Hn (R [E.si] [1] , R [E.si] [2], Sr)} var H = ht (Sr); para (w = 0; w <M.length; ++ w) if (Hr> = M [w] [0] .sr && H.r <= M [w] [0] .er) if (Hc> = M [w] [0] .sc && H.c <= M [w] [0] .e.c) xF = M [w] [1]} if (St == nulo && x.v === indefinido) {if (xf || xF) {xv = 0; xt = "n"} más si (! c. sheetStubs) continue; else xt = "z"} else xt = St || "n"; if (hsc> _) hsc = _; if (hec <_) hec = _; switch (xt) {case "n" : if (xv == "" || xv == null) {if (! c.sheetStubs) continue; xt = "z"} else xv = parseFloat (xv); break; case "s": if (typeof xv == "undefined") {if (! c.sheetStubs) continue; xt = "z"} else {A = Gn [parseInt (xv, 10)]; xv = At; xr = Ar; if (c.cellHTML) xh = Ah} break; case "str": xt = "s"; xv = xv! = null? Xe (xv): ""; if (c.cellHTML) xh = $ e (xv); break; case " inlineStr ": g = y.match (a); xt =" s "; if (g! = null && (A = Ea (g [1])))) {xv = At; if (c.cellHTML) xh = Ah } else xv = ""; break; case "b": xv = Ve (xv); break; case "d": if (c.cellDates) xv = se (xv,1); else {xv = re (se (xv, 1)); xt = "n"} break; case "e": if (! C || c.cellText! == false) xw = xv; xv = RBErr [xv]; break;} T = F = 0; D = nulo; if (O && S.s! == undefined) {D = d.CellXf [Ss]; if (D! = Null) {if (D. numFmtId! = null) T = D.numFmtId; if (c.cellStyles) {if (D.fillId! = null) F = D.fillId}}} ei (x, T, F, c, u, d); if (c.cellDates && O && x.t == "n" && P.is_date (P._table [T])) {xt = "d"; xv = te (xv)} if (N) {var V = ht (Sr) ; if (! f [Vr]) f [Vr] = []; f [Vr] [Vc] = x} más f [Sr] = x}} if (I.length> 0) f ["! rows" ] = I}} (); función Di (e, r, t, a) {var n = [], i = [], s = vt (e ["! Ref"]), l = "", o , f = "", c = [], h = 0, u = 0, d = e ["! filas"]; var p = Array.isArray (e); var v = {r: f}, m, g = -1; para (u = ssc; u <= sec; ++ u) c [u] = lt (u); para (h = ssr; h <= ser; ++ h) {i = [] ; f = at (h); for (u = ssc; u <= sec; ++ u) {o = c [u] + f; var b = p? (e [h] || []) [u ]: e [o];if (b === undefined) continue; if ((l = Fi (b, o, e, r, t, a))! = null) i.push (l)} if (i.length> 0 || d && d [h]) {v = {r: f}; if (d && d [h]) {m = d [h]; if (m.hidden) v.hidden = 1; g = -1; if (m. hpx) g = qa (m.hpx); si no (m.hpt) g = m.hpt; if (g> -1) {v.ht = g; v.customHeight = 1} if (m.level) {v.outlineLevel = m.level}} n [n.length] = sr ("row", i.join (""), v)}} if (d) for (; h <d.length; ++ h) {if (d && d [h]) {v = {r: h + 1}; m = d [h]; if (m.hidden) v.hidden = 1; g = -1; if (m.hpx ) g = qa (m.hpx); si no es (m.hpt) g = m.hpt; if (g> -1) {v.ht = g; v.customHeight = 1} if (m.level) { v.outlineLevel = m.level} n [n.length] = sr ("row", "", v)}} return n.join ("")} var Mi = sr ("hoja de trabajo", nulo, {xmlns : fr.main [0], "xmlns: r": fr.r}); función Pi (e, r, t, a) {var n = [Ae, Mi]; var i = t.SheetNames [e] , s = 0, l = ""; var o = t. Hojas [i]; if (o == null) o = {}; var f = o ["! ref"] || "A1";var c = vt (f); if (cec> 16383 || cer> 1048575) {if (r.WTF) arroja un nuevo error ("Range" + f + "excede el límite de formato A1: XFD1048576"); cec = Math.min (cec, 16383); cer = Math.min (cec, 1048575); f = pt (c)} if (! a) a = {}; o ["! comments"] = []; var h = [] ; vi (o, t, e, r, n); n [n.length] = sr ("dimension", null, {ref: f}); n [n.length] = Ti (o, r, e , t); if (r.sheetFormat) n [n.length] = sr ("sheetFormatPr", nulo, {defaultRowHeight: r.sheetFormat.defaultRowHeight || "16", baseColWidth: r.sheetFormat.baseColWidth || "10 ", outlineLevelRow: r.sheetFormat.outlineLevelRow ||" 7 "}); if (o ["! cols "]! = null && o ["! cols "]. length> 0) n [n.length] = Si (o , o ["! cols"]); n [s = n.length] = "<sheetData />"; o ["! links"] = []; if (o ["! ref"]! = null) {l = Di (o, r, e, t, a); if (l.length> 0) n [n.length] = l} if (n.length> s + 1) {n [n.length] = "</sheetData>"; n [s] = n [s] .replace ("/>", ">")} if (o ["! protect "]! = nulo) n [n.length] = bi (o ["! protect "]); if (o ["! autofilter "]! = null) n [n.length] = _ i (o ["! autofiltro "], o, t, e); if (o ["! merges "]! = null && o ["! merges "]. length> 0) n [n.length] = di (o ["! merges "] ); var u = -1, d, p = -1; if (o ["! links"]. length> 0) {n [n.length] = "<hyperlinks>"; o ["! links"] .forEach (function (e) {if (! e [1] .Target) return; d = {ref: e [0]}; if (e [1] .Target.charAt (0)! = "#") {p = na (a, -1, Be (e [1] .Target) .replace (/#.*$/, ""), Kt.HLINK); d ["r: id"] = "rId" + p} if ((u = e [1] .Target.indexOf ("#"))> - 1) d.location = Be (e [1] .Target.slice (u + 1)); if (e [1] .Tooltip) d.tooltip = Be (e [1] .Tooltip); n [n.length] = sr ("hipervínculo ", nulo, d)}); n [n.length] =" </hyperlinks> "} eliminar o ["! enlaces "]; if (o ["! márgenes "]! = nulo) n [n. longitud] = yi (o ["! márgenes"]); if (! r || r.ignoreEC || r.ignoreEC == nulo 0) n [n.length] = nr ("ignoredErrors", sr ("ignoredError ", nulo, {numberStoredAsText: 1, sqref: f})); if (h.length> 0) {p = na (a, -1," ../ dibujos / dibujo "+ (e + 1) +" .xml ", Kt.DRAW); n [n.length] = sr (" drawing ", null, {" r: id ":" rId "+ p}); o ["! drawing "] = h} if (o ["! comments"]. length> 0) {p = na (a, -1, "../ drawings / vmlDrawing" + (e + 1) + ". vml", Kt.VML); n [ n.length] = sr ("legacyDrawing", nulo, {"r: id": "rId" + p}); o ["! legacy"] = p} if (n.length> 1) {n [n .length] = "</worksheet>"; n [1] = n [1] .replace ("/>", ">")} return n.join ("")} Kt.CHART = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart"; Kt.CHARTEX = "http://schemas.microsoft.com/ office / 2014 / relations / chartEx "; función Ri (e) {var r = []; var t = e.match (/ ^ <c: numCache> /); var a; (e.match (/ <c: pt idx = "(\ d *)"> (. *?) <\ / c: pt> / gm) || []). forEach (function (e) {var a = e.match (/ <c: pt idx = "(\ d *?)"> <c: v> (. *) <\ / c: v> <\ / c: pt> /); if (! a) return; r [+ a [ 1]] = t? + A [2]: a [2]}); var n = Ne ((e.match (/ <c: formatCode> ([\ s \ S] *?) <\ / C: formatCode> /) || ["", "General"]) [1]); (e.match (/ <c: f> (. *?) <\ / c: f> / gm) || [] ) .forEach (function (e) {a = e.replace (/<.*?>/ g, "")}); return [r, n, a]} function Ni (e, r, t, a, n, i) {var s = i || {"! type": "chart"}; if (! e) return i; var l = 0, o = 0, f = "A";var c = {s: {r: 2e6, c: 2e6}, e: {r: 0, c: 0}}; (e.match (/ <c: numCache> [\ s \ S] *? <\ /c:numCache>/gm)||[font>).forEach(function(e){var r = Ri (e); csr = csc = 0; cec = l; f = lt (l); r [0] .forEach (function (e, t) {s [f + at (t)] = {t: "n", v: e, z: r [1]}; o = t}); if (cer <o ) cer = o; ++ l}); if (l> 0) s ["! ref"] = pt (c); return s} Kt.CS = "http://schemas.openxmlformats.org/officeDocument/ 2006 / relations / chartheet "; var Ii = sr (" chartheet ", null, {xmlns: fr.main [0]," xmlns: r ": fr.r}); función Li (e, r, t, a , n) {if (! e) return e; if (! a) a = {"! id": {}}; var i = {"! type": "chart", "! drawel": null, " ! rel ":" "}; var s; var l = e.match (ci); if (l) pi (l [0], i, n, t); if (s = e.match (/ drawing r : id = "(. *?)" /)) i ["! rel"] = s [1]; if (a ["! id"] [i ["! rel"]]) i ["! drawel "] = a ["! id "] [i ["! rel"]]; devuelve la función i} Bi (e, r, t, a) {var n = [Ae, Ii]; n [n.length] = sr ("drawing", null, {"r: id": "rId1"}); na (a, -1, "../ dibujos / dibujo" + (e + 1) + ". xml", Kt.DRAW); if (n.length > 2) {n [n.length] = "</chartsheet>"; n [1] = n [1] .replace ("/>", ">")} return n.join ("")} función zi (e, r) {e.l + = 10; var t = parse_XLWideString (e, r-10); return {name: t}} función Wi (e, r, t, a, n) {if (! e ) devuelve e; if (! a) a = {"! id": {}}; var i = {"! type": "chart", "! drawel": null, "! rel": ""}; var s = []; var l = falso; Jr (e, función o (e, a, f) {switch (f) {case 550: i ["! rel"] = e; break; caso 651: if ( ! n.Sheets [t]) n.Sheets [t] = {}; if (e.name) n.Sheets [t] .CodeName = e.name; break; caso 562:; caso 652:; caso 669: ; caso 679:; caso 551:; caso 552:; caso 476:; caso 3072: descanso;caso 35: l = verdadero; descanso; caso 36: l = falso; descanso; caso 37: s.push (a); descanso; caso 38: s.pop (); descanso; predeterminado: if ((a || " ") .indexOf (" Begin ")> 0) s.push (a); else if ((a ||" "). indexOf (" End ")> 0) s.pop (); else if (! l || r.WTF) arrojar un nuevo error ("Registro inesperado" + f + "" + a);}}, r); if (a ["! id"] [i ["! rel"]]) i [" ! drawel "] = a ["! id "] [i ["! rel "]]; return i} function $ i () {var e = Zr (); qr (e," BrtBeginSheet "); qr (e , "BrtEndSheet"); return e.end ()} var Ui = [["allowRefreshQuery", false, "bool"], ["autoCompressPictures", true, "bool"], ["backupFile", false, "bool "], [" checkCompatibility ", false," bool "], [" CodeName "," "], [" date1904 ", false," bool "], ["defaultThemeVersion ", 0," int "], [" filterPrivacy ", false," bool "], [" hidePivotFieldList ", false," bool "], [" promptedSolutions ", false," bool "], [" PublishItems " , false, "bool"], ["refreshAllConnections", false, "bool"], ["saveExternalLinkValues", true, "bool"], ["showBorderUnselectedTables", true, "bool"], ["showInkAnnotation", true , "bool"], ["showObjects", "all"], ["showPivotChartFilter", false, "bool"], ["updateLinks", "userSet"]]; var ji = [["activeTab", 0, "int"], ["autoFilterDateGrouping", true, "bool"], ["firstSheet", 0, "int"], ["minimized", false, "bool"], ["showHorizontalScroll ", verdadero," bool "], [" showSheetTabs ", verdadero," bool "], [" showVerticalScroll ", verdadero," bool "], [" tabRatio ", 600," int "], [" visibilidad " , "visible"]]; var Hi = []; var Vi = [["calcCompleted", "true"], ["calcMode", "auto"], ["calcOnSave", "true"], ["concurrentCalc "," true "], [" fullCalcOnLoad "," false "], [" fullPrecision "," true "], [" iterate "," false "], [" iterateCount "," 100 "], [" iterateDelta "," 0.001 "], [" refMode "," A1 "]]; función Xi (e, r) {for (var t = 0; t! = E.length; ++ t) {var a = e [ t]; para (var n = 0; n! = r.length; ++ n) {var i = r [n]; if (a [i [0]] == null) a [i [0]] = i [1]; otro interruptor (i [2]) {case "bool":if (typeof a [i [0]] == "string") a [i [0]] = Ve (a [i [0]]); break; case "int": if (typeof a [i [0 ]] == "cadena") a [i [0]] = parseInt (a [i [0]], 10); break;}}}} function Gi (e, r) {for (var t = 0; t! = r.length; ++ t) {var a = r [t]; if (e [a [0]] == null) e [a [0]] = a [1]; else switch (a [2]) {case "bool": if (typeof e [a [0]] == "string") e [a [0]] = Ve (e [a [0]]); break; case "int ": if (typeof e [a [0]] ==" string ") e [a [0]] = parseInt (e [a [0]], 10); break;}}} function Yi (e) { Gi (e.WBProps, Ui); Gi (e.CalcPr, Vi); Xi (e.WBView, ji); Xi (e.Sheets, Hi); Yn.date1904 = Ve (e.WBProps.date1904)} función Ji (e) {if (! E.Workbook) devuelve "false"; if (! E.Workbook.WBProps) devuelve "false"; devuelve Ve (e.Workbook.WBProps.date1904)? "True": "false" } var Zi = "] [*? / \\". split (""); función qi (e, r) {if (e.length> 31) {if (r) devuelve falso; arroja un nuevo error ("Los nombres de las hojas no pueden exceder los 31 caracteres ")} var t = true; Zi.forEach (function (a) {if (e.indexOf (a) == - 1) return; if (! R) arroja un nuevo error (" Nombre de la hoja no puede contener: \\ /? * [] "); t = false}); devuelve t} función Ki (e, r, t) {e.forEach (function (a, n) {qi (a); for ( var i = 0; i <n; ++ i) if (a == e [i]) arroja un nuevo error ("Nombre de hoja duplicado:" + a); if (t) {var s = r && r [n] && r [n] .CodeName || a; if (s.charCodeAt (0) == 95 && s.length> 22) arroja un nuevo error ("Bad Code Name: Worksheet" + s)}})} function Qi (e) {if (! e ||! e.SheetNames ||! e.Sheets) arroja un nuevo error ("Libro de trabajo no válido"); si (! e.SheetNames.length) arroja un nuevo error ("El libro de trabajo está vacío"); var r = e .Workbook && e.Workbook.Sheets || []; Ki (e.SheetNames, r, !! e.vbaraw); for (var t = 0; t <e.SheetNames.length; ++ t) ri (e.Sheets [e.SheetNames [t]], e.SheetNames [t], t)} var es = / <\ w +: libro de trabajo /;función rs (e, r) {if (! e) arroja un nuevo error ("No se pudo encontrar el archivo"); var t = {AppVersion: {}, WBProps: {}, WBView: [], Hojas: [], CalcPr : {}, Nombres: [], xmlns: ""}; var a = falso, n = "xmlns"; var i = {}, s = 0; e.replace (Te, función l (o, f) { var c = De (o); switch (Me (c [0])) {case "<? xml": break; case "<workbook": if (o.match (es)) n = "xmlns" + o .match (/ <(\ w +): /) [1]; t.xmlns = c [n]; break; case "</workbook>": break; case "<fileVersion": delete c [0]; t .AppVersion = c; break; case "<fileVersion />" :; case "</fileVersion>": break; case "<fileSharing": break; case "<fileSharing />": break; case "<workbookPr": ; case "<workbookPr />": Ui.forEach (function (e) {if (c [e [0]] == null) return; switch (e [2]) {case "bool": t.WBProps [ e [0]] = Ve (c [e [0]]); descanso;caso "int": t.WBProps [e [0]] = parseInt (c [e [0]], 10); pausa; valor predeterminado: t.WBProps [e [0]] = c [e [0]]; }}); if (c.codeName) t.WBProps.CodeName = c.codeName; break; case "</workbookPr>": break; case "<workbookProtection": break; case "<workbookProtection />": break; case "<bookViews":; case "<bookViews>":; case "</bookViews>": break; case "<workbookView":; case "<workbookView />": delete c [0]; t.WBView. push (c); break; case "</workbookView>": break; case "<sheet":; case "<sheets>":; case "</sheets>": break; case "<sheet": switch ( c.state) {case "hidden": c.Hidden = 1; break; case "veryHidden": c.Hidden = 2; break; default: c.Hidden = 0;} delete c.state; c.name = Ne (Xe (c.name)); eliminar c [0]; t.Sheets.push (c); break;case "</sheet>": break; case "<functionGroups":; case "<functionGroups />": break; case "<functionGroup": break; case "<externalReferences":; case "</externalReferences>": ; case "<externalReferences>": break; case "<externalReference": break; case "<definedNames />": break; case "<definedNames>":; case "<definedNames": a = true; break; case " </definedNames> ": a = false; break; case" <definedName ": {i = {}; i.Name = Xe (c.name); if (c.comment) i.Comment = c.comment; if (c.localSheetId) i.Sheet = + c.localSheetId; if (Ve (c.hidden || "0")) i.Hidden = true; s = f + o.length} break; case "</definedName> ": {i.Ref = Ne (Xe (e.slice (s, f))); t.Names.push (i)} break; case" <definedName /> ": break; case" <calcPr ": eliminar c [0]; t.CalcPr = c; break; case" <calcPr /> ": eliminar c [0]; t.CalcPr = c; break; case" </calcPr> ": break; case "<oleSize": break; case "<customWorkbookViews>":; case "</customWorkbookViews>":; case "<customWorkbookViews": break; case "<customWorkbookView":; case "</customWorkbookView>": break; case "<pivotCaches>":; case "</pivotCaches>":; case "<pivotCaches": break; case "<pivotCache": break; case "<smartTagPr":; case "<smartTagPr />": break; case "<smartTagTypes":; case "<smartTagTypes>":; case "</smartTagTypes>": break; case "<smartTagType": break; case "<webPublishing":; case "<webPublishing />":break; case "<fileRecoveryPr":; case "<fileRecoveryPr />": break; case "<webPublishObjects>":; case "<webPublishObjects":; case "</webPublishObjects>": break; case "<webPublishObject": break; case "<extLst":; case "<extLst>":; case "</extLst>":; case "<extLst />": break; case "<ext": a = true; break; case " </ext> ": a = false; break; case" <ArchID ": break; case" <AlternateContent ":; case" <AlternateContent> ": a = true; break; case" </AlternateContent> ": a = false; break; case "<revisionPtr": break; default: if (! a && r.WTF) arroja un nuevo error ("no reconocido" + c [0] + "en el libro de trabajo");} return o}); if (fr. main.indexOf (t.xmlns) === - 1) arrojar un nuevo error ("Espacio de nombres desconocido:" + t.xmlns); Yi (t); return t} var ts = sr ("libro de trabajo", nulo, {xmlns: fr.main [0 ], "xmlns: r": fr.r}); funciona como (e) {var r = [Ae]; r [r.length] = ts; var t = e.Workbook && (e.Workbook.Names || []). length> 0; var a = {codeName: "ThisWorkbook"}; if (e.Workbook && e.Workbook.WBProps) {Ui.forEach (function (r) {if (e.Workbook.WBProps [r [0 ]] == nulo) return; if (e.Workbook.WBProps [r [0]] == r [1]) return; a [r [0]] = e.Workbook.WBProps [r [0]]} ); if (e.Workbook.WBProps.CodeName) {a.codeName = e.Workbook.WBProps.CodeName; eliminar a.CodeName}} r [r.length] = sr ("workbookPr", null, a); var n = e.Workbook && e.Workbook.Sheets || []; var i = 0; r [r.length] = "<sheets>"; for (i = 0; i! = e.SheetNames.length; ++ i ) {var s = {nombre: Be (e.SheetNames [i] .slice (0,31))}; s.sheetId = "" + (i + 1); s ["r: id"] = "rId "+ (i + 1); if (n [i]) switch (n [i] .Hidden) {case 1: s.state =" hidden "; break; case 2: s.state =" veryHidden "; break;} r [r.length] = sr ("sheet", null, s)} r [r.length] = "</sheets>"; if (t) {r [r.length] = "<definedNames > "; if (e.Workbook && e.Workbook.Names) e.Workbook.Names.forEach (function (e) {var t = {name: e.Name}; if (e.Comment) t.comment = e.Comment ; if (e.Sheet! = null) t.localSheetId = "" + e.Sheet; if (e.Hidden) t.hidden = "1"; if (! e.Ref) return; r [r.length] = sr ("definedName", String (e.Ref) .replace (/ </ g, "& lt;"). replace (/> / g, "& gt;"), t)}); r [r.length ] = "</definedNames>"} if (r.length> 2) {r [r.length] = "</workbook>"; r [1] = r [1] .replace ("/>", " > ")} return r.join (" ")} function ns (e, r, t) {if (r.slice (-4) ===".bin ") return parse_wb_bin (e, t); return rs (e, t)} la función es (e, r, t, a, n, i, s, l) {if (r.slice (-4) = == ". bin") devuelve parse_ws_bin (e, a, t, n, i, s, l); devuelve ui (e, a, t, n, i, s, l)} función ss (e, r, t, a, n, i, s, l) {if (r.slice (-4) === ". bin") devuelve Wi (e, a, t, n, i, s, l); devuelve Li (e, a, t, n, i, s, l)} función ls (e, r, t, a, n, i, s, l) {if (r.slice (-4) === ". bin ") devuelve Bn (e, a, t, n, i, s, l); devuelve zn (e, a, t, n, i, s, l)} función os (e, r, t, a, n, i, s, l) {if (r.slice (-4) === ". bin") devuelve In (e, a, t, n, i, s, l); devuelve Ln (e, a , t, n, i, s, l)} función fs (e, r, t, a) {if (r.slice (-4) === ". bin") return parse_sty_bin (e, t, a) ; return cn (e, t, a)} función cs (e, r, t) {return yn (e, t)} función hs (e, r, t) {if (r.slice (-4) == = ". bin") return parse_sst_bin (e, t); return Da (e, t)} funciona con nosotros (e, r, t) {if (r.slice (-4) === ". bin") return parse_comments_bin (e, t); devuelve Fn (e, t)} función ds (e, r,t) {if (r.slice (-4) === ". bin") devuelve parse_cc_bin (e, r, t); devuelve parse_cc_xml (e, r, t)} función ps (e, r, t, a ) {if (t.slice (-4) === ". bin") devuelve Cn (e, r, t, a); devuelve la función Sn (e, r, t, a)} vs (e, r, t) {return (r.slice (-4) === ". bin"? write_wb_bin: as) (e, t)} función ms (e, r, t, a, n) {return (r.slice ( -4) === ". Bin"? Write_ws_bin: Pi) (e, t, a, n)} función gs (e, r, t, a, n) {return (r.slice (-4) == = ". bin"? $ i: Bi) (e, t, a, n)} función bs (e, r, t) {return (r.slice (-4) === ". bin"? write_sty_bin: un) (e, t)} función ws (e, r, t) {return (r.slice (-4) === ". bin"? write_sst_bin: Pa) (e, t)} función ks (e, r, t) {return (r.slice (-4) === ". bin"? write_comments_bin: Dn) (e, t)} var ys = function () {function e (e, r) {var t = r || {}; if (m! = null && t.dense == null) t.dense = m; var a = t.dense? []: {}; e = e.replace (/<!--.* ? -> / g, ""); var n = e.match (/ <table / i); if (!n) arrojar un nuevo error ("HTML no válido: no se pudo encontrar <table>"); var i = e.match (/ <\ / table / i); var s = n.index, l = i && i.index || e .length; var o = de (e.slice (s, l), / (:? <tr [^>] *>) / i, "<tr>"); var f = -1, c = 0, h = 0, u = 0; var d = {s: {r: 1e7, c: 1e7}, e: {r: 0, c: 0}}; var p = []; para (s = 0; s <o.length; ++ s) {var v = o [s] .trim (); var g = v.slice (0,3) .toLowerCase (); if (g == "<tr") {+ + f; if (t.sheetRows && t.sheetRows <= f) {- f; break} c = 0; continuar} if (g! = "<td" && g! = "<th") continuar; var b = v .split (/ <\ / t [dh]> / i); for (l = 0; l <b.length; ++ l) {var w = b [l] .trim (); if (! w. match (/ <t [dh] / i)) continuar; var k = w, y = 0; while (k.charAt (0) == "<" && (y = k.indexOf (">"))> -1) k = k.slice (y + 1); for (var x = 0; x <p.length; ++ x) {var S = p [x]; if (Ssc == c && S.sr <f && f <= Ser) {c = Sec + 1;x = -1}} var C = De (w.slice (0, w.indexOf (">"))); u = C.colspan? + C.colspan: 1; if ((h = + C.rowspan )> 1 || u> 1) p.push ({s: {r: f, c: c}, e: {r: f + (h || 1) -1, c: c + u-1}} ); var _ = Ct || ""; if (! k.length) {c + = u; continue} k = Ke (k); if (dsr> f) dsr = f; if (der <f) der = f; if (dsc> c) dsc = c; if (dec <c) dec = c; if (! k.length) continue; var A = {t: "s", v: k}; if (t. raw ||! k.trim (). length || _ == "s") {} else if (k === "TRUE") A = {t: "b", v: true}; else if ( k === "FALSO") A = {t: "b", v: falso}; de lo contrario si (! isNaN (ce (k))) A = {t: "n", v: ce (k)} ; si if (! isNaN (he (k) .getDate ())) {A = {t: "d", v: se (k)}; if (! t.cellDates) A ​​= {t: "n" , v: re (Av)}; Az = t.dateNF || P._table [14]} if (t.dense) {if (! a [f]) ​​a [f] = []; a [f] [c] = A} más a [ut ({r: f, c: c})] = A; c + = u}} a ["! ref"] = pt (d); if (p.length) a ["! merges"] = p; devuelve una} función r (r,t) {return bt (e (r, t), t)} función t (e, r, t, a) {var n = e ["! merges"] || []; var i = []; para (var s = rsc; s <= rec; ++ s) {var l = 0, o = 0; for (var f = 0; f <n.length; ++ f) {if (n [f]. sr> t || n [f] .sc> s) continuar; if (n [f] .er <t || n [f] .ec <s) continuar; if (n [f] .sr <t | | n [f] .sc <s) {l = -1; break} l = n [f] .er-n [f] .s.r + 1; o = n [f] .ec-n [f ] .s.c + 1; break} if (l <0) continue; var c = ut ({r: t, c: s}); var h = a.dense? (e [t] || [] ) [s]: e [c]; var u = h && h.v! = nulo && (hh || $ e (hw || (gt (h), hw) || "")) || ""; var d = {}; if (l> 1) d.rowspan = l; if (o> 1) d.colspan = o; dt = h && h.t || "z"; if (a.editable) u = '<span contenteditable = "true"> '+ u + "</span>"; d.id = (a.id || "sjs") + "-" + c; i.push (sr ("td", u, d ))} var p = "<tr>"; devuelve p + i.join ("") + "</tr>"} función a (e,r, t) {var a = []; devuelve a.join ("") + "<table" + (t && t.id? 'id = "' + t.id + '"': "") + ">" } var n = '<html> <head> <meta charset = "utf-8" /> <title> Exportación de tabla SheetJS </title> </head> <body>'; var i = "</body> < / html> "; función s (e, r) {var s = r || {}; var l = s.header! = null? s.header: n; var o = s.footer! = null? s. pie de página: i; var f = [l]; var c = dt (e ["! ref"]); s.dense = Array.isArray (e); f.push (a (e, c, s)); para (var h = csr; h <= cer; ++ h) f.push (t (e, c, h, s)); f.push ("</table>" + o); return f.join ("")} return {to_workbook: r, to_sheet: e, _row: t, BEGIN: n, END: i, _preamble: a, from_sheet: s}} (); function xs (e, r) {var t = r || {}; if (m! = null) t.dense = m; var a = t.dense? []: {}; var n = e.getElementsByTagName ("tr"); var i = t.sheetRows || 1e7; var s = {s: {r: 0, c: 0}, e: {r: 0, c: 0}}; var l = [], o = 0; var f = []; var c = 0, h = 0, u = 0, d = 0, p = 0, v = 0; para (; c <n.length && h <i; ++ c) {var g = n [c]; if (Cs (g)) {if (t.display) continue; f [h] = {hidden: true}} var b = g.children; for (u = d = 0; u <b.length; ++ u ) {var w = b [u]; if (t.display && Cs (w)) continue; var k = Ke (w.innerHTML); for (o = 0; o <l.length; ++ o) {var y = l [o]; if (ysc == d && y.sr <= h && h <= yer) {d = yec + 1; o = -1}} v = + w.getAttribute ("colspan") || 1; if ((p = + w.getAttribute ("rowspan"))> 0 || v> 1) l.push ({s: {r: h, c: d}, e: {r: h + (p || 1 ) -1, c: d + v-1}}); var x = {t: "s", v: k}; var S = w.getAttribute ("t") || ""; if (k! = nulo) {if (k.length == 0) xt = S || "z"; sino if (t.raw || k.trim (). length == 0 || S == "s") { } else if (k === "TRUE") x = {t: "b", v: true}; else if (k === "FALSE") x = {t: "b", v:falso}; si if (! isNaN (ce (k))) x = {t: "n", v: ce (k)}; si if (! isNaN (he (k) .getDate ())) {x = {t: "d", v: se (k)}; if (! t.cellDates) x = {t: "n", v: re (xv)}; xz = t.dateNF || P._table [14]}} if (t.dense) {
if (! a [h]) a [h] = []; a [h] [d] = x} más a [ut ({c: d, r: h})] = x; if (sec <d ) sec = d; d + = v} ++ h} if (l.length) a ["! merges"] = l; if (f.length) a ["! rows"] = f; ser = h-1 ; a ["! ref"] = pt (s); if (h> = i) a ["! fullref"] = pt ((ser = n.length-c + h-1, s)); devuelve un } función Ss (e, r) {return bt (xs (e, r), r)} función Cs (e) {var r = ""; var t = _s (e); if (t) r = t ( e) .getPropertyValue ("display"); if (! r) r = e.style.display; return r === "none"} function _s (e) {if (e.ownerDocument.defaultView && typeof e.ownerDocument.defaultView .getComputedStyle === "function") return e.ownerDocument.defaultView.getComputedStyle; if (typeof getComputedStyle === "function") return getComputedStyle; return null} function As (e, r) {if (! r) return 0 ; var t = e.SheetNames.indexOf (r); if (t == - 1) arroja un nuevo error ("Hoja no encontrada:" + r);return t} function Es (e) {return function r (t, a) {var n = As (t, a.sheet); return e.from_sheet (t.Sheets [t.SheetNames [n]], a, t )}} var Ts = Es (ys); var Fs = Es ({from_sheet: gl}); var Os = Es (typeof SYLK! == "undefined"? SYLK: {}); var Ds = Es (typeof DIF ! == "undefined"? DIF: {}); var Ms = Es (typeof PRN! == "undefined"? PRN: {}); var Ps = Es (typeof RTF! == "undefined"? RTF: { }); var Rs = Es ({from_sheet: bl}); var Ns = Es (typeof DBF! == "undefined"? DBF: {}); var Is = Es (typeof ETH! == "undefined"? ETH : {}); función Ls (e) {función de retorno r (t) {para (var a = 0; a! = e.length; ++ a) {var n = e [a]; if (t [n [0]] === indefinido) t [n [0]] = n [1]; if (n [2] === "n") t [n [0]] = Número (t [n [0] ]])}}} var Bs = Ls ([["cellNF", false], ["cellHTML", true], ["cellFormula", true], ["cellStyles", false], ["cellText", true ], ["cellDates", false],["sheetStubs", false], ["sheetRows", 0, "n"], ["bookDeps", false], ["bookSheets", false], ["bookProps", false], ["bookFiles", false ], ["bookVBA", falso], ["contraseña", ""], ["WTF", falso]]); var zs = Ls ([["cellDates", falso], ["bookSST", falso] , ["tipo de libro", "xlsx"], ["compresión", falso], ["WTF", falso]]); función Ws (e) {if (Kt.WS.indexOf (e)> - 1) return "hoja"; if (Kt.CS && e == Kt.CS) devuelve "gráfico"; if (Kt.DS && e == Kt.DS) devuelve "diálogo"; if (Kt.MS && e == Kt.MS) devuelve "macro" "; return e && e.length? e:" sheet "} function $ s (e, r) {if (! e) return 0; try {e = r.map (function a (r) {if (! r.id ) r.id = r.strRelID; devuelve [r.name, e ["! id"] [r.id] .Target, Ws (e ["!id "] [r.id] .Type)]})} catch (t) {return null} return! e || e.length === 0? null: e} funcion Us (e, r, t, a , n, i, s, l, o, f, c, h) {try {i [a] = ea (ke (e, t, true), r); var u = we (e, r); var d; switch (l) {case "sheet": d = is (u, r, n, o, i [a], f, c, h); break; case "chart": d = ss (u, r , n, o, i [a], f, c, h); if (! d ||! d ["! drawel"]) break; var p = _e (d ["! drawel"]. Target, r ); var v = Qt (p); var m = _n (ke (e, p, verdadero), ea (ke (e, v, verdadero), p)); var g = _e (m, p); var b = Qt (g); d = Ni (ke (e, g, verdadero), g, o, ea (ke (e, b, verdadero), g), f, d); descanso; caso "macro": d = ls (u, r, n, o, i [a], f, c, h); pausa; "diálogo" de mayúsculas y minúsculas: d = os (u, r, n, o, i [a], f, c, h); pausa; predeterminado: arrojar un nuevo error ("Tipo de hoja no reconocido" + l);} s [a] = d; var w = []; if (i && i [a]) Y (i [a]) .forEach (function (t) {if (i [a] [t] .Type == Kt.CMNT) {var n = _e (i [a] [t] .Target, r); w = us (we ( e, n, verdadero), n, o); if (! w ||! w.length) return; Tn (d, w)}})} catch (k) {if (o.WTF) throw k}} función js (e) {return e.charAt (0) == "/"? E.slice (1): e} función Hs (e, r) {R (P); r = r || {}; Bs (r); if (ge (e, "META-INF / manifest.xml")) return parse_ods (e, r); if (ge (e, "objectdata.xml")) return parse_ods (e, r); if (ge (e, "Index / Document.iwa")) arroja un nuevo error ("archivo NUMBERS no admitidos"); var t = ye (e); var a = Yt (ke (e, " [Content_Types] .xml ")); var n = false; var i, s; if (a.workbooks.length === 0) {s =" xl / workbook.xml "; if (we (e, s, true)) a.workbooks.push (s)} if (a.workbooks.length === 0) {s = "xl / workbook.bin"; if (! we (e, s, true)) arroja un nuevo error ("No se pudo encontrar el libro de trabajo"); a.workbooks.push (s); n = true} if (a.workbooks [0] .slice (-3) == "bin") n = true; var l = { }; var o = {}; if (! r.bookSheets &&! r.bookProps) {Gn = []; if (a.sst) intente {Gn = hs (we (e, js (a.sst)), a .sst, r)} catch (f) {if (r.WTF) throw f} if (r.cellStyles && a.themes.length) l = cs (ke (e, a.themes [0] .replace (/ ^ \ //, ""), true) || "", a.themes [0], r); if (a.style) o = fs (we (e, js (a.style)), a.style, l, r)} a.links.map (function (t) {try {var a = ea (ke (e, Qt (js (t))), t); devuelve ps (we (e, js (t)), a, t, r)} catch (n) {}}); var c = ns (we (e, js (a.books [0])), a.books [0], r); var h = {}, u = ""; if (a.coreprops.length) {u = we (e, js (a.coreprops [0]), verdadero); if (u) h = la (u); if (a.extprops.length! == 0) {u = we (e, js (a.extprops [0 ]), verdadero); if (u) pa (u, h, r)}} var d = {}; if (! r.bookSheets || r.bookProps) {if (a.custprops.length! == 0 ) {u = ke (e, js (a.custprops [0]), verdadero); if (u) d = ba (u, r)}} var p = {}; if (r.bookSheets || r. bookProps) {if (c.Sheets) i = c.Sheets.map (function T (e) {return e.name}); else if (h.Worksheets && h.SheetNames.length> 0) i = h.SheetNames; if (r.bookProps) {p.Props = h; p.Custprops = d} if (r.bookSheets && typeof i! == "undefined ") p.SheetNames = i; if (r.bookSheets? p.SheetNames: r.bookProps) return p} i = {}; var v = {}; if (r.bookDeps && a.calcchain) v = ds (we (e, js (a.calcchain)), a.calcchain, r); var m = 0; var g = {}; var b, w; {var k = c.Sheets; h.Worksheets = k.length; h.SheetNames = []; for (var y = 0; y! = k.length; ++ y) {h.SheetNames [y] = k [y] .name}} var x = n? "bin": "xml"; var S = a.books [0] .lastIndexOf ("/"); var C = (a.books [0] .slice (0, S + 1) + "_ rels /" + a.workbooks [ 0] .slice (S + 1) + ". Rels"). Replace (/ ^ \ //, ""); if (! Ge (e, C)) C = "xl / _rels / workbook." + X + ".rels"; var _ = ea (ke (e, C, verdadero), C); if (_) _ = $ s (_, c.Sheets); var A = we (e, "xl / worksheets / sheet.xml ", true)? 1: 0; for (m = 0; m! = h.Worksheets; ++ m) {var E =" sheet "; if (_ && _ [m]) {b =" xl / "+ _ [m] [1] .replace (/ [\ /]? xl \ //," "); if (! ge (e, b)) b = _ [m] [1]; if (! Caramba,b)) b = C.replace (/ _ rels \ /.*$/, "") + _ [m] [1]; E = _ [m] [2]} else {b = "xl / worksheets / sheet "+ (m + 1-A) +". "+ x; b = b.replace (/ sheet0 \ ./," sheet. ")} w = b.replace (/^(.*)(\/) ([^ \ /] *) $ /, "$ 1 / _rels / $ 3.rels"); Us (e, b, w, h. SheetNames [m], m, g, i, E, r, c, l , o)} p = {Directorio: a, Libro de trabajo: c, Props: h, Custprops: d, Deps: v, Sheets: i, SheetNames: h.SheetNames, Strings: Gn, Styles: o, Themes: l, SSF : P.get_table ()}; if (r.bookFiles) {p.keys = t; p.files = e.files} if (r.bookVBA) {if (a.vba.length> 0) p.vbaraw = nosotros (e, js (a.vba [0]), verdadero); si no (a.defaults && a.defaults.bin === Mn) p.vbaraw = we (e, "xl / vbaProject.bin", verdadero) } return p} función Vs (e, r) {var t = r || {}; var a = "Libro de trabajo", n = j.find (e, a); intente {a = "/! DataSpaces / Version" ; n = j.find (e, a); if (! n ||! n.content) arroja un nuevo error ("Falta el archivo cifrado ECMA-376" + a); parse_DataSpaceVersionInfo (n.contenido); a = "/! DataSpaces / DataSpaceMap"; n = j.find (e, a); if (! n ||! n.content) arroja un nuevo error ("Falta el archivo cifrado ECMA-376" + a) ; var i = parse_DataSpaceMap (n.content); if (i.length! == 1 || i [0] .comps.length! == 1 || i [0] .comps [0] .t! == 0 || i [0] .name! == "StrongEncryptionDataSpace" || i [0] .comps [0] .v! == "EncryptedPackage") arrojar un nuevo error ("ECMA-376 Archivo cifrado incorrecto" + a) ; a = "/! DataSpaces / DataSpaceInfo / StrongEncryptionDataSpace"; n = j.find (e, a); if (! n ||! n.content) arroja un nuevo error ("Falta el archivo cifrado ECMA-376" + a) ; var s = parse_DataSpaceDefinition (n.content); if (s.length! = 1 || s [0]! = "StrongEncryptionTransform") arroja un nuevo error ("ECMA-376 Archivo cifrado incorrecto" + a); a = " /!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary";n=j.find(e,a);if(!n||!n.content)throw new Error ("ECMA-376 Falta el archivo cifrado "+ a); parse_Primary (n.content)} catch (l) {} a =" / EncryptionInfo "; n = j.find (e, a); if (! N ||! N .content) arrojar un nuevo error ("Falta el archivo cifrado ECMA-376" + a); var o = parse_EncryptionInfo (n.content); a = "/ EncryptedPackage"; n = j.find (e, a); if (! n ||! n.content) arrojar un nuevo error ("Falta el archivo cifrado ECMA-376" + a); if (o [0] == 4 && typeof decrypt_agile! == "undefined") devuelve decrypt_agile (o [1], n .content, t.password || "", t); if (o [0] == 2 && typeof decrypt_std76! == "undefined") devuelve decrypt_std76 (o [1], n.content, t.password || "" , t); arrojar un nuevo error ("El archivo está protegido con contraseña")} función Xs (e, r) {An = 1024; if (r.bookType == "ods") devuelve write_ods (e, r); if ( e &&! e.SSF) {e.SSF = P.get_table ()} if (e && e.SSF) {R (P); P.load_table (e.SSF); r.revssf = q (e.SSF); r.revssf [e.SSF [65535]] = 0; r.ssf = e.SSF} r.rels = {}; r.wbrels = {}; r.Strings = [ ]; r.Strings.Count = 0; r.Strings.Unique = 0; if (Jn) r.revStrings = new Map; else {r.revStrings = {}; r.revStrings.foo = []; eliminar r. revStrings.foo} var t = r.bookType == "xlsb"? "bin": "xml"; var a = Nn.indexOf (r.bookType)> - 1; var n = Gt (); zs (r = r || {}); var i = Se (); var s = "", l = 0; r.cellXfs = []; Qn (r.cellXfs, {}, {revssf: {General: 0}}) ; if (! e.Props) e.Props = {}; s = "docProps / core.xml"; xe (i, s, ca (e.Props, r)); n.coreprops.push (s); na (r.rels, 2, s, Kt.CORE_PROPS); s = "docProps / app.xml"; if (e.Props && e.Props.SheetNames) {} más if (! e.Workbook ||! e.Workbook .Sheets) e.Props.SheetNames = e.SheetNames; sino {var o = []; for (var f = 0; f <e.SheetNames.length; ++ f) if ((e.Workbook.Sheets [f ] || {}). ¡Oculto! = 2) o.push (e.SheetNames [f]); e.Props.SheetNames = o} e.Props.Worksheets = e.Props.SheetNames.length; xe (i, s, ma (e.Props, r)); n.extprops.push (s); na (r.rels, 3, s, Kt.EXT_PROPS); if (e. Custprops! == e.Props && Y (e.Custprops || {}). Length> 0) {s = "docProps / custom.xml"; xe (i, s, ka (e.Custprops, r)); n. custprops.push (s); na (r.rels, 4, s, Kt.CUST_PROPS)} para (l = 1; l <= e.SheetNames.length; ++ l) {var c = {"! id" : {}}; var h = e.Sheets [e.SheetNames [l-1]]; var u = (h || {}) ["! type"] || "sheet"; switch (u) {case "chart":; default: s = "xl / worksheets / sheet" + l + "." + t; xe (i, s, ms (l-1, s, r, e, c)); n.sheets. push (s); na (r.wbrels, -1, "hojas de trabajo / hoja" + l + "." + t, Kt.WS [0]);} if (h) {var d = h ["! comments" ]; var p = falso; if (d && d.length> 0) {var v = "xl / comments" + l + "." + t; xe (i, v, ks (d, v, r)); n. comments.push (v); na (c, -1, "../ comments" + l + "." + t, Kt.CMNT);p = verdadero} if (h ["! legacy"]) {if (p) xe (i, "xl / drawings / vmlDrawing" + l + ". vml", En (l, h ["! comments"])) } eliminar h ["! comentarios"]; eliminar h ["! legacy"]} if (c ["! id"]. rId1) xe (i, Qt (s), ta (c))} if (r. Strings! = Null && r.Strings.length> 0) {s = "xl / sharedStrings." + T; xe (i, s, ws (r.Strings, s, r)); n.strs.push (s); na (r.wbrels, -1, "sharedStrings." + t, Kt.SST)} s = "xl / workbook." + t; xe (i, s, vs (e, s, r)); n. workbooks.push (s); na (r.rels, 1, s, Kt.WB); s = "xl / theme / theme1.xml"; xe (i, s, xn (e.Themes, r)); n.themes.push (s); na (r.wbrels, -1, "theme / theme1.xml", Kt.THEME); s = "xl / styles." + t; xe (i, s, bs ( e, s, r)); n.styles.push (s); na (r.wbrels, -1, "styles." + t, Kt.STY); if (e.vbaraw && a) {s = "xl / vbaProject.bin "; xe (i, s, e.vbaraw); n.vba.push (s); na (r.wbrels, -1," vbaProject.bin ", Kt.VBA)} xe (i," [Content_Types] .xml ", qt (n, r)); xe (i," _ rels / .rels ", ta (r.rels)); xe (i , "xl / _rels / workbook." + t + ". rels", ta (r.wbrels)); eliminar r.revssf; eliminar r.ssf; devolver i} función Gs (e, r) {var t = "" ; switch ((r || {}). type || "base64") {case "buffer": return [e [0], e [1], e [2], e [3]]; case "base64 ": t = b.decode (e.slice (0,24)); break; case" binary ": t = e; break; case" array ": return [e [0], e [1], e [ 2], e [3]]; valor predeterminado: arrojar un nuevo error ("Tipo no reconocido" + (r && r.type || "undefined"));} return [t.charCodeAt (0), t.charCodeAt (1), t .charCodeAt (2), t.charCodeAt (3)]} función Ys (e, r) {if (j.find (e, "EncryptedPackage")) devuelve Vs (e, r); devuelve parse_xlscfb (e, r) } función Js (e, r) {var t, a = e; var n = r || {}; if (! n.type) n.type = w && Buffer.isBuffer (e)? "buffer":"base64"; t = Ce (a, n); devuelve Hs (t, n)} función Zs (e, r) {var t = 0; e: while (t <e.length) switch (e.charCodeAt ( t)) {caso 10:; caso 13:; caso 32: ++ t; descanso; caso 60: retorno parse_xlml (e.slice (t), r); valor predeterminado: descanso e;} retorno PRN.to_workbook (e, r)} función qs (e, r) {var t = "", a = Gs (e, r); switch (r.type) {case "base64": t = b.decode (e); break; case "binary": t = e; break; case "buffer": t = e.toString ("binary"); break; case "array": t = le (e); break; default: throw new Error ("Unrecognized escriba "+ r.type);} if (a [0] == 239 && a [1] == 187 && a [2] == 191) t = Xe (t); devuelve Zs (t, r)} función Ks (e , r) {var t = e; if (r.type == "base64") t = b.decode (t); t = cptable.utils.decode (1200, t.slice (2), "str") ; r.type = "binary"; return Zs (t, r)} function Qs (e) {return! e.match (/ [^ \ x00- \ x7F] /)? e: Ge (e)} function el (e, r, t, a) {if (a) {t.type = "string"; return PRN.to_workbook (e, t)} return PRN.to_workbook (r, t)} function rl (e, r) {f (); if (typeof ArrayBuffer! == "undefined" && e instanceof ArrayBuffer) return rl (nuevo Uint8Array (e), r); var t = e, a = [0,0,0,0], n = falso; var i = r || {}; if (i.cellStyles) {i.cellNF = true} Yn = {}; if (i.dateNF) Yn.dateNF = i.dateNF; if (! i.type) i.type = w && Buffer.isBuffer (e)? "buffer": "base64 "; if (i.type ==" file ") {i.type = w?" buffer ":" binary "; t = G (e)} if (i.type ==" string ") {n = true ; i.type = "binary"; i.codepage = 65001; t = Qs (e)} if (i.type == "array" && typeof Uint8Array! == "undefined" && e instanceof Uint8Array && typeof ArrayBuffer! == "undefined" ) {var s = new ArrayBuffer (3), l = new Uint8Array (s); l.foo = "bar"; if (! l.foo) {i = oe (i); i.type = "array";return rl (F (t), i)}} switch ((a = Gs (t, i)) [0]) {case 208: return Ys (j.read (t, i), i); case 9: if (a [1] <= 4) return parse_xlscfb (t, i); break; caso 60: return parse_xlml (t, i); caso 73: if (a [1] === 68) return read_wb_ID (t, i); break; caso 84: if (a [1] === 65 && a [2] === 66 && a [3] === 76) devuelve DIF.to_workbook (t, i); break; caso 80: devuelve un [1] === 75 && a [2] <9 && a [3] <9? Js (t, i): el (e, t, i, n); caso 239: devuelve a [3] === 60? Parse_xlml (t, i): el (e, t, i, n); caso 255: if (a [1] === 254) {return Ks (t, i)} break; caso 0: if (a [1 ] === 0 && a [2]> = 2 && a [3] === 0) devuelve WK_.to_workbook (t, i); break; caso 3:; caso 131:; caso 139:; caso 140: devuelve DBF.to_workbook (t, i); caso 123: if (a [1] === 92 && a [2] === 114 && a [3] === 116) devuelva RTF.to_workbook (t, i); break; caso 10 :; caso 13:; caso 32: devuelve qs (t, i);} if (a [2] <= 12 && a [3] <= 31) devuelve DBF.to_workbook (t, i); devuelve el (e, t, i ,n)} función tl (e, r) {var t = r || {}; t.type = "file"; return rl (e, t)} function al (e, r) {switch (r.type) {case "base64":; case "binary": break; case "buffer":; case "array": r.type = ""; break; case "file": return X (r.file, j.write ( e, {type: w? "buffer": ""})); case "string": arrojar nuevo error ("tipo de salida '' string 'no válido para'" + r.bookType + "'files"); valor predeterminado: arrojar nuevo Error ("Tipo no reconocido" + tipo r);} return j.write (e, r)} función nl (e, r) {var t = r || {}; var a = Xs (e, t); var n = {}; if (t.compression) n.compression = "DEFLATE"; if (t.password) n.type = w? "nodebuffer": "string"; else switch (t.type) {case " base64 ": n.type =" base64 "; break; case" binary ": n.type =" string "; break; case" string ":lanzar un nuevo error ("tipo de salida '' cadena 'no válido para'" + t.bookType + "'archivos"); caso "buffer":; caso "archivo": n.type = w? "nodebuffer": "cadena"; romper ; predeterminado: arrojar un nuevo error ("Tipo no reconocido" + t.type);} var i = a.FullPaths? j.write (a, {fileType: "zip", tipo: {nodebuffer: "buffer", string: " binario "} [n.type] || n.type}): a.generate (n); if (t.password && typeof encrypt_agile! ==" undefined ") devuelve al (encrypt_agile (i, t.password), t) ; if (t.type === "file") return X (t.file, i); return t.type == "string"? Xe (i): i} function il (e, r) {var t = r || {}; var a = write_xlscfb (e, t); devuelve al (a, t)} función sl (e, r, t) {if (! t) t = ""; var a = t + e; switch (tipo r) {case "base64": return b.encode (Ge (a)); case "binary": return Ge (a); case "string ": return e; case" file ": return X (r.file, a," utf8 "); case" buffer ": {if (w) return k (a," utf8 "); else return sl (a , {type: "binary"}). split (""). map (function (e) {return e.charCodeAt (0)})};} throw new Error ("Tipo no reconocido" + r.type)} function ll (e, r) {switch (r.type) {case "base64": return b.encode (e); case "binary": return e; case "string": return e; case "file": return X (r.file, e, "binary"); case "buffer": {if (w) return k (e, "binary"); else return e.split (""). map (function (e) {return e.charCodeAt (0)})};} arrojar un nuevo error ("Tipo no reconocido" + tipo r)} función ol (e, r) {switch (tipo r) "case" string ":; case" base64 " :; case "binary": var t = ""; for (var a = 0; a <e.length; ++ a) t + = String.fromCharCode (e [a]); return r.type == "base64"? b.encode (t): r.type == "string"? Xe (t): t; case "file": return X (r .file, e); case "buffer": return e; default: throw new Error ("Tipo no reconocido" + tipo r);}} function fl (e, r) {f (); Qi (e); var t = r || {}; if (t.cellStyles) {t.cellNF = true} if (t.type == "array") {t.type = "binary"; var a = fl (e, t) ; t.type = "array"; return A (a)} switch (t.bookType || "xlsb") {case "xml":; case "xlml": return sl (write_xlml (e, t), t) ; case "slk":; case "sylk": return sl (Os (e, t), t); case "htm":; case "html": return sl (Ts (e, t), t); case "txt": return ll (Rs (e, t), t); case "csv": return sl (Fs (e, t), t, "\ ufeff"); case "dif": return sl (Ds ( e, t), t); caso "dbf": devuelve ol (Ns (e, t), t); caso "prn":return sl (Ms (e, t), t); case "rtf": return sl (Ps (e, t), t); case "eth": return sl (Is (e, t), t); case "fods": return sl (write_ods (e, t), t); case "biff2": if (! t.biff) t.biff = 2; case "biff3": if (! t.biff) t.biff = 3; case "biff4": if (! T.biff) t.biff = 4; return ol (write_biff_buf (e, t), t); case "biff5": if (! T.biff) t.biff = 5; case "biff8":; case "xla":; case "xls": if (! T.biff) t.biff = 8; return il (e, t); case "xlsx":; case "xlsm" :; case "xlam":; case "xlsb":; case "ods": return nl (e, t); default: arroja un nuevo error ("BookType no reconocido |" + t.bookType + "|");}} función cl (e) {if (e.bookType) return; var r = {xls: "biff8", htm: "html", slk: "sylk", socialcalc: "eth", Sh33tJS: "WTF"}; var t = e.file.slice (e.file.lastIndexOf (".")). toLowerCase (); if (t.match (/ ^ \. [az] + $ /)) e.bookType = t.slice (1); e.bookType = r [e.bookType ] || e.bookType} función hl (e, r, t) {var a = t || {}; a.type = "file"; a.file = r; cl (a); return fl (e, a)} función ul (e, r, t, a) {var n = t || {}; n.type = "file"; n.file = e; cl (n); n.type = "buffer" ; var i = a; if (! (i instanceof Function)) i = t; return H.writeFile (e, fl (r, n), i)} function dl (e, r, t, a, n, i , s, l) {var o = at (t); var f = l.defval, c = l.raw ||! l.hasOwnProperty ("raw"); var h = verdadero; var u = n === 1? []: {}; If (n! == 1) {if (Object.defineProperty) intente {Object.defineProperty (u, "__ rowNum __", {value: t, enumerable: false})} catch (d) {u .__ rowNum __ = t} más u .__ rowNum __ = t} if (! s || e [t]) for (var p = rsc; p <= rec; ++ p) {var v = s? e [t ] [p]: e [a [p] + o]; if (v === undefined || vt === undefined) {if (f === undefined) continuar; if (i [p]! = null ) {u [i [p]] = f} continuar} var m = vv; cambiar (v.t) {case "z": if (m == null) break; continue; case "e": m = void 0; break; case "s":; case "d":; case "b":; case "n": pausa; valor predeterminado: arrojar un nuevo error ("tipo no reconocido" + vt);} if (i [p]! = null) {if (m == null) {if (f! == undefined) u [ i [p]] = f; sino if (c && m === null) u [i [p]] = null; else continue} else {u [i [p]] = c? m: gt (v, m, l)} if (m! = null) h = false}} return {row: u, isempty: h}} function pl (e, r) {if (e == null || e ["! ref"] = = nulo) return []; var t = {t: "n", v: 0}, a = 0, n = 1, i = [], s = 0, l = ""; var o = {s: {r: 0, c: 0}, e: {r: 0, c: 0}}; var f = r || {}; var c = f.range! = nulo? f.range: e ["! ref "]; if (f.header === 1) a = 1; else if (f.header ===" A ") a = 2; else if (Array.isArray (f.header)) a = 3 ; si if (f.header == null) a = 0; switch (typeof c) {case "string": o = vt (c); break; case "number": o = vt (e ["! ref" ]); osr = c; descanso;valor predeterminado: o = c;} if (a> 0) n = 0; var h = at (osr); var u = []; var d = []; var p = 0, v = 0; var m = Array .isArray (e); var g = osr, b = 0, w = 0; if (m &&! e [g]) e [g] = []; for (b = osc; b <= oec; ++ b ) {u [b] = lt (b); t = m? e [g] [b]: e [u [b] + h]; conmutador (a) {caso 1: i [b] = bo.sc ; break; caso 2: i [b] = u [b]; break; caso 3: i [b] = f.header [bo.sc]; break; valor predeterminado: if (t == null) t = {w : "__ EMPTY", t: "s"}; l = s = gt (t, null, f); v = 0; for (w = 0; w <i.length; ++ w) if (i [w ] == l) l = s + "_" + ++ v; i [b] = l;}} para (g = osr + n; g <= oer; ++ g) {var k = dl (e, o, g, u, a, i, m, f); if (k.isempty === false || (a === 1? f.blankrows! == false: !! f.blankrows)) d [ p ++] = k.row} d.length = p; return d} var vl = / "/ g; función ml (e, r, t, a, n, i, s, l) {var o = verdadero; var f = [], c = "", h = at (t); for (var u = rsc; u <= rec; ++ u) {if (! a [u]) continue; var d = l.dense ? (e [t] || []) [u]: e [a [u] + h]; if (d == null) c = ""; si if (dv! = null) {o = false; c = "" + gt (d,nulo, l); para (var p = 0, v = 0; p! == c.length; ++ p) if ((v = c.charCodeAt (p)) === n || v === i || v === 34) {c = '"' + c.replace (vl, '" "') + '"'; break} if (c == "ID") c = '"ID"' } else if (df! = null &&! dF) {o = false; c = "=" + df; if (c.indexOf (",")> = 0) c = '"' + c.replace (vl, '""') + '"'} más c =" "; f.push (c)} if (l.blankrows === false && o) return null; return f.join (s)} function gl (e, r ) {var t = []; var a = r == null? {}: r; if (e == null || e ["! ref"] == null) return ""; var n = vt (e ["! ref"]); var i = a.FS! == undefined? a.FS: ",", s = i.charCodeAt (0); var l = a.RS! == undefined? a.RS : "\ n", o = l.charCodeAt (0); var f = new RegExp ((i == "|"? "\\ |": i) + "+ $"); var c = "", h = []; a.dense = Array.isArray (e); var u = a.skipHidden && e ["! cols"] || []; var d = a.skipHidden && e ["! rows"] || []; for (var p = nsc; p <= nec; ++ p) if (! (u [p] || {}). oculto) h [p] = lt (p); para (var v = nsr; v <= ner; ++ v) {if ((d [v] || {}) .hidden) continuar; c = ml (e, n, v, h, s, o, i, a); if (c == null) {continuar} if (a.strip) c = c.replace (f, ""); t.push (c + l)} eliminar a.dense; devolver t.join ("")} función bl (e, r) {if (! r) r = {}; r.FS = " \ t "; r.RS =" \ n "; var t = gl (e, r); if (typeof cptable ==" undefined "|| r.type ==" string ") devuelve t; var a = cptable .utils.encode (1200, t, "str"); devuelve String.fromCharCode (255) + String.fromCharCode (254) + a} función wl (e) {var r = "", t, a = ""; if (e == null || e ["! ref"] == null) return []; var n = vt (e ["! ref"]), i = "", s = [], l; var o = []; var f = Array.isArray (e); for (l = nsc; l <= nec; ++ l) s [l] = lt (l);for (var c = nsr; c <= ner; ++ c) {i = at (c); for (l = nsc; l <= nec; ++ l) {r = s [l] + i; t = f? (e [c] || []) [l]: e [r]; a = ""; if (t === undefined) continuar; si if (tF! = null) {r = tF; if (! tf) continue; a = tf; if (r.indexOf (":") == - 1) r = r + ":" + r} if (tf! = null) a = tf; si if (tt == "z") continuar; si if (tt == "n" && t.v! = null) a = "" + tv; si if (tt == "b") a = tv? "TRUE": " FALSE "; si if (tw! == undefined) a =" '"+ tw; else if (tv === undefined) continuar; si if (tt ==" s ") a ="' "+ tv; else a = "" + tv; o [o.length] = r + "=" + a}} return o} function kl (e, r, t) {var a = t || {}; var n = +! a .skipHeader; var i = e || {}; var s = 0, l = 0; if (i && a.origin! = null) {if (typeof a.origin == "number") s = a.origin; else {var o = typeof a.origin == "string"? ht (a.origin): a.origin; s = or;l = oc}} var f; var c = {s: {c: 0, r: 0}, e: {c: l, r: s + r.length-1 + n}}; if (i [" ! ref "]) {var h = vt (i ["! ref "]); cec = Math.max (cec, hec); cer = Math.max (cer, her); if (s == - 1) {s = cer + 1; cer = s + r.length-1 + n}} var u = a.header || [], d = 0; r.forEach (function (e, r) {Y (e) .forEach (function (t) {if ((d = u.indexOf (t)) == - 1) u [d = u.length] = t; var o = e [t]; var c = "z" ; var h = ""; var p = ut ({c: l + d, r: s + r + n}); f = xl.sheet_get_cell (i, p); if (o && typeof o === "objeto" &&! (o instanceof Date)) {i [p] = o} else {if (typeof o == "number") c = "n"; else if (typeof o == "boolean") c = "b" ; else if (typeof o == "string") c = "s"; else if (o instanceof Date) {c = "d"; if (! a.cellDates) {c = "n"; o = re ( o)} h = a.dateNF || P._table [14]} if (! f) i [p] = f = {t: c, v: o}; else {ft = c; fv = o; delete fw; eliminar fR; if (h) fz = h} if (h) f.z = h}})}); cec = Math.max (cec, l + u.length-1); var p = at (s); if (n) para (d = 0; d <u.length; ++ d) i [lt (d + l) + p] = {t: "s", v: u [d]}; i ["! ref"] = pt (c); devuelve i} función yl ( e, r) {return kl (null, e, r)} var xl = {encode_col: lt, encode_row: at, encode_cell: ut, encode_range: pt, decode_col: st, decode_row: tt, split_cell: ct, decode_cell: ht , decode_range: dt, format_cell: gt, get_formulae: wl, make_csv: gl, make_json: pl, make_formulae: wl, sheet_add_aoa: wt, sheet_add_json: kl, aoa_to_sheet: kt, json_to_sheet: ilo, table_to_sheet: xs, table_to_book: Ss, sheet_to_csv : gl, sheet_to_txt: bl, sheet_to_json: pl, sheet_to_html: ys.from_sheet, sheet_to_formulae: wl, sheet_to_row_object_array: pl}; (function (e) {e.consts = e.consts || {}; function r (r) { r.forEach (function (r) {e.consts [r [0]] = r [1]})} function t (e, r, t) {return e [r]! = null? e [r]: e [r] = t} función a (e, r, t) {if (typeof r == "string") {if (Array.isArray (e)) {var n = ht (r); if (! e [nr]) e [nr] = []; return e [nr] [nc] || (e [nr] [nc] = { t: "z"})} devuelve e [r] || (e [r] = {t: "z"})} if (typeof r! = "number") devuelve a (e, ut (r)) ; devuelve a (e, ut ({r: r, c: t || 0}))} e.sheet_get_cell = a; función n (e, r) {if (typeof r == "number") {if ( r> = 0 && e.SheetNames.length> r) return r; arrojar un nuevo error ("No se puede encontrar la hoja #" + r)} más if (typeof r == "string") {var t = e.SheetNames.indexOf (r ); si (t> -1) devuelve t; arrojar un nuevo error ("No se puede encontrar el nombre de la hoja |" + r + "|")} de lo contrario arrojar un nuevo error ("No se puede encontrar la hoja |" + r + "|")} e. book_new = function () {return {SheetNames: [], Sheets: {}}}; e.book_append_sheet = function (e, r, t) {if (! t) for (var a = 1; a <= 65535; ++ a) if (e.SheetNames.indexOf (t = "Sheet" + a) == - 1) break; if (! t) arroja un nuevo Error ("Demasiadas hojas de trabajo"); qi (t);if (e.SheetNames.indexOf (t)> = 0) arroja un nuevo error ("Hoja de trabajo con nombre |" + t + "| ya existe!"); e.SheetNames.push (t); hojas de correo electrónico [t] = r}; e.book_set_sheet_visibility = function (e, r, a) {t (e, "Workbook", {}); t (e.Workbook, "Sheets", []); var i = n (e, r ); t (e.Workbook.Sheets, i, {}); switch (a) {case 0:; case 1:; case 2: break; default: throw new Error ("Configuración de visibilidad de hoja incorrecta" + a); } e.Workbook.Sheets [i] .Hidden = a}; r ([["SHEET_VISIBLE", 0], ["SHEET_HIDDEN", ​​1], ["SHEET_VERY_HIDDEN", ​​2]]); e.cell_set_number_format = function ( e, r) {ez = r; return e}; e.cell_set_hyperlink = function (e, r, t) {if (! r) {delete el} else {el = {Target: r}; if (t) elTooltip = t} return e}; e.cell_set_internal_link = function (r, t, a) {return e.cell_set_hyperlink (r, "#" + t, a)}; e.cell_add_comment = function (e, r, t) { if (! ec) ec = []; ecpush ({t: r, a:t || "SheetJS"})}; e.sheet_set_array_formula = function (e, r, t) {var n = typeof r! = "string"? r: vt (r); var i = typeof r == "string "? r: pt (r); for (var s = nsr; s <= ner; ++ s) for (var l = nsc; l <= nec; ++ l) {var o = a (e, s , l); ot = "n"; oF = i; eliminar ov; if (s == nsr && l == nsc) of = t} return e}; return e}) (xl); if (typeof parse_xlscfb! == "undefined") e.parse_xlscfb = parse_xlscfb; e.parse_zip = Hs; e.read = rl; e.readFile = tl; e.readFileSync = tl; e.write = fl; e.writeFile = hl; e.writeFileSync = hl; e.writeFileAsync = ul; e.utils = xl; e.SSF = P; if (typeof j! == "undefined") e.CFB = j} if (typeof exportaciones! == "undefined") make_xlsx_lib ( exportaciones); si if (typeof module! == "undefined" && module.exports) make_xlsx_lib (module.exports); else if (typeof define === "function" && define.amd) define ("xlsx", function () { Si(!XLSX.version) make_xlsx_lib (XLSX); return XLSX}); else make_xlsx_lib (XLSX); var XLS = XLSX, ODS = XLSX;